# 《微服务架构设计模式》第1章~第2章 读书笔记

![封面](.\图片\微服务架构设计模式_封面.png)

## 书籍简介

基于微服务架构的应用软件开发需要掌握一系列全新的架构思想和实践。在本书中，作者 Chris Richardson 收集、分类并解释了多个微服务架构设计模式，这些模式用来解决诸如服务拆分、事务管理、查询和跨服务通信等难题。本书将介绍如何开发和部署生产级别的可在真实条件下可靠地扩展和执行的微服务架构应用，以帮助你设计、实现、测试和部署基于微服务的应用程序。

## 读后感想

之前其实已经读过这本书了，只是没有好好做下笔记。现在写读书笔记发现内容也确实比较多，所以按章节拆开来记录吧——不然写成单篇读书笔记太长了（这样弄感觉我也写不完，捂脸）。

看这本书的原因，主要就是想系统地去了解一下微服务架构相关的知识。以前很多概念都是在学习Spring Cloud、Dubbo或者相关框架的时候，看到微服务概念相关的只言片语，没有完整全面地去学习过微服务。看过这本书后，发现很多之前注意到的细节，都被系统整理成了一个个设计模式，感觉是对自己的微服务相关知识库的一次整理、学习与提升。

书中还有很多实践相关的代码示例，如果实战需要的话，也可以作为参考。不过我自己读书感觉这种部分总是偷懒，不太想看书本上的源码，看不进去…… 以后有机会自己写写相关代码再来读吧（说是这样说，真正做起来也不知道啥时候……）。不过单论那些理论部分，其实读下来收获就不少了。

第1章主要就是简单介绍了一下单体系统和微服务系统的定义、差异与优缺点。感觉面试题还是蛮喜欢问这些的。

第2章主要就是介绍微服务的拆分，所以具体介绍了架构的定义、如何进行拆分以及拆分的难点。其中六边形架构的描述方式对于我来说还是挺新颖的，感觉比较适合描述那些多个对外接口、多个消息队列、多种数据库的情况；之前自己只了解分层架构。

## 书中概念

### 第1章 逃离单体地狱

**软件架构**的定义：

卡耐基梅隆大学软件工程研究所的 Len Bass 及其同事，他们在使软件架构成为一门学科方面发挥了关键作用。他们定义的软件架构如下：

> 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。
>
> —— Bass 等著《Documenting Software Architectures: Views and Beyond》



### 第2章 服务的拆分策略

**服务**是一个单一的、可独立部署的软件组件，它实现了一些有用的功能。服务的API封装了其内部实现。

**松耦合**：微服务架构的最核心特性是服务之间的松耦合性。服务之间的交互采用API完成，这样做就封装了服务的实现细节。这允许服务在不影响客户端而对情况下，对实现方式做出修改。



**系统操作**（system operation）是应用程序必须处理的请求的一种抽象描述。它既可以是更新数据的命令，也可以是检索数据的查询。每个命令的行为都是根据抽象领域模型定义的，抽象领域模型也是从需求中派生出来的。系统操作是描述服务之间协作方式的架构场景。

**业务能力**是一个来自于业务架构建模的术语。业务能力是指一些能够为公司（或组织）产生价值的商业活动。特定业务的业务能力取决于这个业务的类型。

**领域模型**以解决具体问题的方式包含了一个领域内的知识。它定义了当前领域相关团队的词汇表，DDD也称之为**通用语言**（Ubiquitous language）。领域模型会被紧密地映射到应用的设计和实现环节。

**限界上下文**：DDD把领域模型的边界称为**限界上下文**（bounded context）。限界上下文包括实现这个模型的代码集合。



## 章节简介

### 第1章 逃离单体地狱

#### 1.1 迈向单体地狱的漫长旅程

##### 1.1.2 单体架构的好处

- **应用的开发很简单**：IDE和其他开发工具只需要构建这一个单独的应用程序
- **易于对应用程序进行大规模的更改**：可以更改代码和数据库模式，然后构建和部署。
- **测试相对简单直观**：开发者只需要写几个端到端的测试，启动应用程序，调用REST API，然后使用Selenium这样的工具测试用户界面。
- **部署简单明了**：开发者唯一需要做的，就是把WAR文件复制到安装了Tomcat的服务器上。
- **横向扩展不费吹灰之力**：FTGO可以运行多个实例，由一个负载均衡器进行调度。



##### 1.1.3 什么是单体地狱

- **过度的复杂性会吓退开发者**
- **开发速度缓慢**
- **从代码提交到实际部署的周期很长，而且容易出问题**
- **难以扩展**。有些情况下，应用的不同模式对资源的需求是相互冲突的。因为这些模块都是在一个应用程序内，因此在选用服务器时必须满足所有模块的需要。
- **交付可靠的单体应用是一项挑战**
- **需要长期依赖某个可能已经过时的技术栈**



#### 1.4 拯救之道：微服务架构

##### 1.4.1 扩展立方体和服务

- **X轴扩展：在多个实例之间请求的负载均衡**
  又称为水平复制，通过克隆实例的方式扩展
- **Y轴扩展：根据功能把应用拆分为服务**
  又称为功能性分解，通过分解不同功能的方式来实现扩展。Y轴扩展把一个单体应用分成了一组服务
- **Z轴扩展：根据请求的属性路由请求**
  又称为数据分区，通过类似客户ID的方式，把相似的数据分区进行扩展



##### 1.4.2 微服务架构作为模块化的一种形式

- 单体应用中，模块通常由一组编程语言所提供的结构（例如 Java 的包），或者 Java JAR文件这样的构建制品（artifact）来定义。
- 微服务架构使用服务作为模块化的单元。服务的 API 为它自身构筑了一个不可逾越的边界，你无法越过 API 去访问服务内部的类，这与采用 Java 包的单体应用完全不同。



##### 1.4.3 每个服务都拥有自己的数据库

微服务架构的一个关键特性是每一个服务之间都是松耦合的，它们仅通过API进行通信。实现这种松耦合的方式之一，是每个服务都拥有自己的私有数据库。



##### 1.4.5 微服务架构与SOA的异同

|                | SOA                                                          | 微服务                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 服务间通信     | 智能管道，例如 Enterprise Service Bus（ESB），往往采用重量级协议，例如 SOAP 或其他 WS* 标准 | 使用哑管道，例如消息代理，或者服务之间点对点通信，使用例如 REST 或 gRPC 类的轻量级协议 |
| 数据管理       | 全局数据模型并共享数据库                                     | 每个服务都有自己的数据模型和数据库                           |
| 典型服务的规模 | 较大的单体应用                                               | 较小的服务                                                   |



#### 1.5 微服务架构的好处和弊端

##### 1.5.1 微服务架构的好处

- **使大型的复杂应用程序可以持续交付和持续部署**。微服务架构拥有持续交付和持续部署所需要的可测试性和可部署性，且它使开发团队能够自主且松散耦合。
- **每个服务都相对较小并容易维护**。较小规模的代码不会把 IDE 等开发工具拖慢，这样可以提升开发者的工作效率。
- **服务可以独立部署**。
- **服务可以独立扩展**。每个服务都可以部署在适合它们需求的硬件之上。
- **微服务架构可以实现团队的自治**。
- **更容易实验和采纳新的技术**。微服务架构可以消除对某项技术栈的长期依赖。更进一步，因为服务都相对比较小，使用更好的编程语言和技术来重写一项服务变得有可能。
- **更好的容错性**。微服务架构也可以实现更好的故障隔离。

##### 1.5.2 微服务架构的弊端

- **服务的拆分和定义是一项挑战**。
  如果对系统的服务拆分出现了偏差，你很有可能构建出一个**分布式的单体应用**：一个包含了一大堆互相之间紧耦合的服务，却又必须部署在一起的所谓分布式系统。这将会把单体架构和微服务架构两者的弊端集于一身。
- **分布式系统带来的各种复杂性，使开发、测试和部署变得更困难**。
  开发人员必须处理创建分布式系统的额外复杂性。服务必须使用进程间通信机制。必须设计服务来处理局部故障，并处理远程服务不可用或出现高延迟的各种情况。
  实现跨多个服务的用例需要使用不熟悉的技术。
  IDE等开发工具都是为单体应用设计的，它们并不具备开发分布式应用所需要的特定功能支持。
  微服务架构还引入了显著的运维复杂性。
- **当部署跨越多个服务的功能时需要谨慎地协调更多开发团队**。
  必须制定一个发布计划，把服务按照依赖关系进行排序。
- **开发者需要思考到底应该在应用的什么阶段使用微服务架构**。
  快速发展业务模型和维护一个优雅的应用架构之间的取舍。



#### 1.6 微服务架构的模式语言

##### 1.6.1 微服务架构并不是“银弹”

早在1986年，《人月神话》的作者 Fred Brooks 就曾说：软件工程的世界里没有银弹。换一种说法，并不存在一种或几种技术，可以把你的生产效率提升10倍。

> Gartner的**光环曲线**
>
> 光环曲线采用五个阶段来描述新兴技术的发展：
>
> - *萌芽期，又称“技术诱发期”，这一时期是技术探索或公开演示的时期*（原文无此段）
> - 其中的过热期，又被称为**期望释放的顶峰**，代表了人们对新技术的迷恋和崇拜
> - *攀升期，又称“顿悟的斜坡”，这一时期尽管公众关注度下降，讨论新技术不再是时髦的，但是更多的组织对新技术的应用，以及新技术的风险和益处的了解，使得新技术逐步走向商业化的道路*（原文无此段）
> - 紧接着而来的是谷底期，又被称为**失望的山谷**，反映了人们对新技术的失望
> - 光环曲线的最后阶段才是成熟期，又被称为**生产力的高地**，是指人们理解了新技术的优缺点之后开始理性地应用它



##### 1.6.3 微服务架构的模式语言概述

采用微服务架构后引入的新问题的模式被分为三组：

- **基础设施相关模式组**：这些模式解决通常是开发环节跟基础设施有关的问题。
- **应用基础设施相关模式组**：这些模式解决应用层面的基础设施相关问题。
- **应用相关模式组**：这些模式解决开发人员面对的具体技术和架构问题。

![微服务架构模式语言概述](.\图片\微服务架构设计模式_微服务架构模式语言概述.png)

其中有主要的几组模式：

- **服务拆分的相关模式**：根据业务能力分解模式、根据子域分解模式（第2章）
- **通信的相关模式**：通信风格、服务发现、可靠性、事务性消息（第3章）、外部API（第8章）
- **实现事务管理的数据一致性相关模式**：（第4~6章）
- **在微服务架构中查询数据的相关模式**：API组合模式、命令查询职责隔离CQRS（第7章）
- **服务部署的相关模式**：（第12章）
- **可观测性的相关模式**：健康检查API、日志聚合、分布式追踪、异常追踪、应用指标、审计日志（第11章）
- **实现服务自动化测试的相关模式**：消费端驱动的契约测试、消费端契约测试、服务组件测试（第9章和第10章）
- **解决基础设施和边界问题的相关模式**：（第11章）
- **安全相关的模式**：令牌模式（第11章）



### 第2章 服务的拆分策略

#### 2.1 微服务架构到底是什么

##### 2.1.1 软件架构是什么，为什么它如此重要

**软件架构的4+1视图模型**：

![4+1视图模型](.\图片\微服务架构设计模式_4+1视图模型.png)

4是四个不同的软件架构视图

- **逻辑视图**：开发人员创建的软件元素。元素：类和包，关系：它们之间的关系
- **实现视图**：构建编译系统的输出。元素：模块（JAR文件）和组件（WAR文件或可执行文件），关系：它们之间的依赖关系
- **进程视图**：运行时的组件。元素：进程，关系：进程间通信
- **部署视图**：进程如何映射到机器。元素：机器和进程，关系：网络

+1是指场景，它负责把视图串联在一起。每个场景负责描述一个视图中的多个架构元素如何协助，以完成一个请求。



**为什么架构如此重要**：

应用程序有两个层面的需求。第一类是**功能性**需求，这些需求决定一个应用程序做什么。

架构的重要性在于，它帮助应用程序满足了第二类需求：**非功能性**需求。我们把这类需求也称之为**质量属性**需求。比如运行时的可扩展性、可靠性，开发阶段的可维护性、可测试性、可扩展性和可部署性。



##### 2.1.2 什么是架构的风格

**分层式架构风格**

架构的典型例子是分层架构。**分层架构**将软件元素按“层”的方式组织。每个层都有明确定义的职责。分层架构还限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层（如果严格分层）或其下面的任何层。

可以将分层架构应用于前面讨论的四个视图中的任何一个。流行的三层架构是应用于逻辑视图的分层架构。它将应用程序的类组织到以下层中：

- **表现层**：包含实现用户界面或外部API的代码。
- **业务逻辑层**：包含业务逻辑
- **数据持久化层**：实现与数据库交互的逻辑

分层架构是架构风格的一个很好的例子，但它确实有一些明显的弊端：

- **单个表现层**：它无法展现应用程序可能不仅仅由单个系统调用的事实。
- **单一数据持久化层**：它无法展现应用程序可能与多个数据库进行交互的事实。
- **将业务逻辑层定义为依赖于数据持久化层**：理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑。

此外，分层架构错误地表示了精心设计的应用程序中的依赖关系。业务逻辑通常定义数据访问方法的接口或接口库。数据持久化层则定义了实现存储库接口的DAO类。换句话说，依赖关系与分层架构所描述的相反。

克服这些弊端的替代架构：六边形架构。



**六边形架构**

六边形架构是分层架构风格的替代品。六边形架构风格选择以业务逻辑为中心的方式组织逻辑视图。应用程序具有一个或多个**入站适配器**，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。同样，应用程序具有一个或多个**出站适配器**，而不是数据持久化层，这些出站适配器由业务逻辑调用并调用外部应用程序。此架构的一个关键特性和优点是业务逻辑不依赖于适配器。相反，各种适配器都依赖业务逻辑。

业务逻辑具有一个或多个端口（port）。**端口**定义了一组操作，关于业务逻辑如何与外部交互。例如，在Java中，端口通常是Java接口。有两种端口：入站和出站端口。

- 入站端口是业务逻辑公开的API，它使外部应用程序可以调用它。入站端口的一个实例是服务接口，它定义服务的公共方法。
- 出站端口是业务逻辑调用外部系统的方式。出站端口的一个实例是存储库接口，它定义数据访问操作的集合。

业务逻辑周围是适配器。与端口一样，有两种类型的适配器：入站和出站。

- 入站适配器通过调用入站端口来处理来自外部世界的请求。入站适配器的一个实例是Spring MVC Controller，它实现一组REST接口（endpoint）或一组Web页面。另一个实例是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。
- 出站适配器实现出站端口，并通过调用外部应用程序或服务处理来自业务逻辑的请求。出站适配器的一个实例是实现访问数据库的操作的**数据访问对象**（DAO）类。另一个实例是调用远程服务的代理类。出站适配器也可以发布事件。

![六边形架构](.\图片\微服务架构设计模式_六边形架构.png)

六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开来。业务逻辑不依赖于表示层逻辑或数据访问层逻辑。

由于这种分离，单独测试业务逻辑要容易得多。另一个好处是它更准确地反映了现代应用程序的架构。可以通过多个适配器调用业务逻辑，每个适配器实现特定的API或用户界面。业务逻辑还可以调用多个适配器，每个适配器调用不同的外部系统。六边形架构是描述微服务架构中每个服务的架构的好方法。



#### 2.2 为应用程序定义微服务架构

定义应用架构的三步式流程：

- 第一步：定义系统操作
- 第二步：定义服务
- 第三步：定义服务API和协作方式

定义架构的第一步是将应用程序的需求提炼为各种关键请求。**系统操作**（system operation）是应用程序必须处理的请求的一种抽象描述。它既可以是更新数据的命令，也可以是检索数据的查询。每个命令的行为都是根据抽象领域模型定义的，抽象领域模型也是从需求中派生出来的。系统操作是描述服务之间协作方式的架构场景。

该流程的第二步是确定如何分解服务。一种策略源于业务架构学派的策略是定义与业务能力相对应的服务。另一种策略是围绕领域驱动设计的子域来分解和设计服务。这些策略的最终结果都是围绕业务概念而非技术概念分解和设计服务。

定义应用程序架构的第三步是确定每个服务的API。为此，你将第一步中标识的每个系统操作分配给服务。服务可以完全独立地实现操作。或者，它可能需要与其他服务协作。在这种情况下，你可以确定服务的协作方式，这通常需要服务来支持其他操作。你还需要确定选用第3章中描述的哪种进程间通信机制来实现每个服务的API。



##### 2.2.1 识别系统操作

两步式流程识别和定义系统操作：

- 第一步创建由关键类组成的抽象领域模型，这些关键类提供用于描述系统操作的词汇表
- 第二步确定系统操作，并根据领域模型描述每个系统操作的行为

领域模型主要源自用户故事中提及的名词，系统操作主要来自用户故事中提及的动词。

**定义系统操作**

两种类型的系统操作：

- **命令型**：创建、更新或删除数据的系统操作
- **查询型**：查询和读取数据的系统操作



##### 2.2.2 根据业务能力进行服务拆分

**业务能力**是一个来自于业务架构建模的术语。业务能力是指一些能够为公司（或组织）产生价值的商业活动。特定业务的业务能力取决于这个业务的类型。

一旦确定了业务能力，就可以为每个能力或相关能力组定义服务。



##### 2.2.3 根据子域进行服务拆分

Eric Evans在他的经典著作中提出的领域驱动设计是构建复杂软件的方法论，这些软件通常都以面向对象和领域模型为核心。

**领域模型**以解决具体问题的方式包含了一个领域内的知识。它定义了当前领域相关团队的词汇表，DDD也称之为**通用语言**（Ubiquitous language）。领域模型会被紧密地映射到应用的设计和实现环节。

在微服务架构的设计层面，DDD有两个特别重要的概念，子域和限界上下文。

传统的企业架构建模方式往往会为整个企业建立一个单独的模型，DDD则采取了完全不同的方式。领域驱动为每一个子域定义单独的模型。子域是领域的一部分，领域是DDD中用来描述应用程序问题域的一个术语。识别子域的方式跟识别业务能力一样。

DDD把领域模型的边界成为**限界上下文**（bounded context）。限界上下文包括实现这个模型的代码集合。当使用微服务架构时，每一个限界上下文对应一个或者一组服务。换一种说法，我们可以通过DDD的方式定义子域，并把子域对应为每一个服务，这样就完成了微服务架构的设计工作。

DDD和微服务架构简直就是天生一对。DDD的子域和限界上下文的概念，可以很好地跟微服务架构中的服务进行匹配。而且，微服务架构中的自治化团队服务开发的概念，也跟DDD中每个领域模型都由一个独立团队负责开发的概念吻合。更有趣的是，子域用于它自己的领域模型这个概念，为消除上帝类和优化服务拆分提供了好方法。



##### 2.2.4 拆分的指导原则

面向对象设计的一些原则也可以用于指导微服务架构的设计工作。这些原则由 Robert C. Martin 在他的著作《Designing Object Oriented C++ Applications Using The Booch Method》（Prentice Hall, 1995）中提出。

- 第一个原则就是在定义类的职责时，应该遵循**单一职责原则**（Single Responsibility Principle, SRP）。

  > 改变一个类应该只有一个理由。——Robert C. Martin

- 第二个原则是把类组成包时，应该遵循**闭包原则**（Common Closure Principle, CCP）。

  > 在包中包含的所有类应该是对同类的变化的一个集合，也就是说，如果对包做出修改，需要调整的类应该都在这个包之内。——Robert C. Martin



##### 2.2.5 拆分单体应用为服务的难点

- **网络延迟**：网络延迟是分布式系统中一直存在的问题。对服务的特定分解会导致两个服务之间的大量往返调用
- **同步进程间通信导致可用性降低**
- **在服务之间维持数据一致性**
- **获取一致的数据视图**：分解的另一个障碍是无法跨多个数据库获得真正一致的数据视图
- **上帝类阻碍了拆分**：上帝类是在整个应用程序中使用的全局类



##### 2.2.6 定义服务API

- 定义服务API的起点是将每个系统操作映射到服务。

- 之后确定服务是否需要与其他服务协作以实现系统操作。如果需要协作，我们将确定其他服务必须提供哪些API才能支持协作。