# 第1章 整洁代码

## 1.1 要有代码

记住，代码确然是我们最终用来表达需求的那种语言。我们可以创造各种与需求接近的语言。我们可以创造帮助把需求解析和汇整为正式结构的各种工具。然而，我们永远无法抛弃必要的精确性——所以代码永存。

## 1.2 糟糕的代码

勒布朗（LeBlanc）法则：**稍后等于永不**（Later equals never）。

## 1.3 混乱的代价

有些团队在项目初期进展迅速，但有那么一两年的时间却慢如蜗行。对代码的每次修改都影响到其他两三处代码。修改无小事。每次添加或修改代码，都得对那堆扭纹柴了然于心，这样才能往上扔更多的扭纹柴。这团乱麻越来越大，再也无法理清，最后束手无策。

随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降时，管理层就只有一件事可做了：增加更多人手到项目中，期望提升生产力。可是新人并不熟悉系统的设计。他们搞不清楚什么样的修改符合设计意图，什么样的修改违背设计意图。而且，他们以及团队中的其他人都背负着提升生产力的可怕压力。于是，他们制造更多的混乱，驱动生产力向零那端不断下降。

### 1.3.1 华丽新设计

### 1.3.2 态度

多数经理想要知道实情，即便他们看起来不喜欢实情。多数经理想要好代码，即便他们总是痴缠于进度。他们会奋力卫护进度和需求；那是他们该干的。你则当以同等的热情卫护代码。

程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。

### 1.3.3 迷题

程序员面临着一种基础价值谜题。有那么几年经验的开发者都知道，之前的混乱拖了自己的后腿。但开发者们背负期限的压力，只好制造混乱。简而言之，他们没花时间让自己做得更快！

真正的专业人士明白，这道谜题的第二部分说错了。制造混乱无助于赶上期限。混乱只会立刻拖慢你，叫你错过期限。赶上期限的唯一方法——做得快的唯一方法——就是始终尽可能保持代码整洁。

### 1.3.4 整洁代码的艺术

能够分辨整洁代码和脏代码，也不意味着会写整洁代码！

### 1.3.5 什么是整洁代码

> 我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。
>
> ——Bjarne Stroustrup, C++语言发明者，《C++程序设计语言》一书作者

务实的Dave Thomas和Andy Hunt从另一角度阐述了这种情况。他们提到破窗理论。窗户破损了的建筑让人觉得似乎无人照管。于是别人也不再关心。他们放任窗户继续破损。最终自己也参加破坏活动，在外墙涂鸦，任垃圾堆积。一扇破损的窗户开辟了大厦走向倾颓的道路。

> 整洁的代码简单直接，整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直接了当的控制语句。
>
> —— Grady Booch，《面向对象分析与设计》一书作者。

>整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的API。代码应通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。
>
>——“老大”Dave Thomas，OTI公司创始人，Eclipse战略教父

## 1.4 思想流派

## 1.5 我们是作者

Javadoc中的@author字段告诉我们自己是什么人。我们是作者。作者都有读者，实际上，作者有责任与读者做良好沟通。

读与写花费时间的比例超过10：1。写新代码时，我们一直在读旧代码。

## 1.6 童子军军规

光把代码写好可不够。必须时时保持代码整洁。我们都见过代码随时间流逝而腐坏。我们应当更积极地阻止腐坏的发生。

借用美国童子军一条简单的军规，应用到我们的专业领域：

> 让营地比你来时更干净。

如果每次签入时，代码都比签出时干净，那么代码就不会腐坏。清理并不一定要花多少功夫，也许只是改好一个变量名，拆分一个有点过长的函数，消除一点点重复代码，清理一个嵌套if语句。

## 1.7 前传与原则

从许多角度看，本书都是我2002年写那本《敏捷软件开发：原则、模式与实践》，简称PPP,的“前传”。PPP关注面向对象设计的原则，以及专业开发者采用的许多实践方法。

## 1.8 小结



# 第2章 有意义的命名

## 2.1 介绍

## 2.2 名副其实

名副其实说起来简单。我们想要强调，这事很严肃。选个好名字要花时间，但省下来的时间比花掉的多。注意命名，而且一旦发现有更好的名称，就换掉旧的。这么做，读你代码的人（包括你自己）都会更开心。

变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。

~~~java
int d; // 消逝的时间，以日计
~~~

名称d什么也没说明。它没有引起对时间消逝的感觉，更别说以日计了。我们应该选择指明了计量对象和计量单位的名称：

~~~java
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
~~~

选择体现本意的名称能让人更容易理解和修改代码。下列代码的目的何在？

~~~java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for(int[] x: theList)
        if(x[0] == 4)
            list1.add(x);
    return list1;
}
~~~

为什么难以说明上列代码要做什么事？

问题不在于代码的简洁度，而是在于代码的模糊度：即上下文在代码中未被明确体现的程度。上列代码要求我们了解类似以下问题的答案：

1. theList中是什么类型的东西？
2. theList零下标条目的意义是什么？
3. 值4的意义是什么？
4. 我怎么使用返回的列表？

问题的答案没体现在代码段中，可那就是它们该在的地方。比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为theList的单元格列表，那就将其名称改为gameBoard。

盘面上每个单元格都用一个简单数组表示，我们还发现，零下标条目是一种状态值，而该种状态值为4表示“已标记”。只要改为有意义的名称，代码就会得到相当程度的改进：

~~~java
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for(int[] cell : gameBoard) {
        if(cell[STATUS_VALUE] == FLAGGED)
            flaggedCells.add(cell);
    }
    return flaggedCells;
}
~~~

注意，代码的简洁性并未被触及。运算符和常量的数量全然保持不变，嵌套数量也全然保持不变。但代码变得明确多了。

还可以更进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为isFlagged），从而掩盖住那个魔术数。于是得到函数的新版本：

~~~java
public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<Cell>();
    for(Cell cell : gameBoard)
        if(cell.isFlagged())
            flaggedCells.add(cell);
    return flaggedCells;
}
~~~

只要简单改一下名称，就能轻易知道发生了什么。这就是选用好名称的力量。

## 2.3 避免误导

程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。例如，hp、aix和sco都不该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。

别用accountList来指一组账号，除非它真的是List类型。List一词对程序员有特殊意义。如果包纳账号的容器并非真是一个List，就会引起错误的判断。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。

提防使用不同之处较小的名称。

以同样的方式拼写出相同的概念才是信息。拼写前后不一致就是误导。

误导性名称真正可怕的例子，使用小写字母l和大写字母O作为变量名，尤其是在组合使用的时候。当然，问题在于它们看起来完全像是常量“壹”和“零”。

## 2.4 做有意义的区分

如果名称必须相异，那其意思也应该不同才对。

废话是另一种没意义的区分。假设你有一个Product类。如果还有一个ProductInfo或ProductData类，那它们的名称虽然不同，意思却无区别。Info和Data就像a、an和the一样，是意义含混的废话。

注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用名为theZork的变量，麻烦就来了。

废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难道Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。

## 2.5 使用读得出来的名称

## 2.6 使用可搜索的名称

单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。

## 2.7 避免使用编码

编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。

### 2.7.1 匈牙利语标记法

在往昔名称长短很要命的时代，我们毫无必要地破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加上一位数字。匈牙利语标记法（Hungarian Notation，HN）将这种态势愈演愈烈。

在Windows的C语言API的时代，HN相当重要，那时所有名称要么是一个整数句柄，要么是一个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利语标记法来帮助自己记住类型。

现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围之内。

Java程序员不需要类型编码。所以，如今HN和其他类型编码形式都纯属多余。

### 2.7.2 成员前缀

也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。

### 2.7.3 接口和实现

你怎么来命名工厂和具体类呢？IShapeFactory 和 ShapeFactory吗？我喜欢不加修饰的接口。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。

## 2.8 避免思维映射

不应当让读者在脑中把你的名称翻译成为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。

单字母变量名就是个问题。在作用域较小、也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择；读者必须在脑中将它映射为真实概念。仅仅是因为有了a和b，就要命名为c，实在并非像样的理由。

明确是王道。专业程序员善用其能，编写其他人能理解的代码。

## 2.9 类名

类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data和Info这样的类名。类名不应当是动词。

## 2.10 方法名

方法名应当是动词或动词短语。

重载构造器时，使用了描述了参数的静态工厂方法名。例如：

~~~java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
~~~

通常好于

~~~java
Complex fulcrumPoint = new Complex(23.0);
~~~

可以考虑将相应的构造器设置为private，强制使用这种命名手段。

## 2.11 别扮可爱

如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。宁可明确，毋为好玩。

扮可爱的做法在代码中经常体现为使用俗语或俚语。

## 2.12 每个概念对应一个词

## 2.13 别用双关语

## 2.14 使用解决方案领域名称

程序员要做太多技术性工作。给这些事取个技术性的名称，通常是最靠谱的做法。

## 2.15 使用源自所涉问题领域的名称

如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。

优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称。

## 2.16 添加有意义的语境

很少有名称是能自我说明的——多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。

设想你有名为firstName、lastName、street、houseNumber、city、state和zipcode的变量。当它们搁在一块的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零一个state变量呢？你会理所当然推断那是某个地址的一部分吗？

可以添加前缀addr，以此提供语境。至少，读者会明白这些变量是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。

## 2.17 不要添加没用的语境

## 2.18 最后的话

# 第3章 函数

## 3.1 短小

函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。

## 3.2 只做一件事

函数应该做一件事。做好这件事。只做这一件事。

## 3.3 每个函数一个抽象层级

要确保函数只做一件事，函数中的语句都要在同一抽象层级上。

## 3.4 switch语句

写出短小的switch语句很难。即便是只有两种条件的switch语句也要比我想要的单个代码块或函数大得多。写出只做一件事的switch语句也很难。switch天生要做N件事。不幸我们总无法避开switch语句，不过还是能够确保每个switch都埋藏在较低的抽象层级，而且永远不重复。当然，我们利用多态来实现这一点。

请看代码清单3-4。它呈现了可能依赖于雇员类型的仅仅一种操作。

~~~java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
    switch(e.type){
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
~~~

该函数有好几个问题。首先，它太长，当出现新的雇员类型时，还会变得更长。其次，它明显做了不止一件事。第三，它违反了单一权责原则（Signle Responsibility Principle，SRP），因为有好几个修改它的理由。第四，它违反了开放闭合原则（Open Closed Principle，OCP），因为每当添加新类型时，就必须修改之。不过，该函数最麻烦的可能是到处皆有类似结构的函数。例如，可能会有`isPayday(Employee e, Date date)`或`deliverPay(Employee e, Money pay)`如此等等。它们的结构都有同样的问题。

该问题的解决方案（如代码清单3-5所示）是将switch语句埋到抽象工厂底下，不让任何人看到。该工厂使用switch语句为Employee的派生物创建适当的实体，而不同的函数，如calculatePay，isPayday和deliverPay等，则籍由Employee接口多态地接收派遣。

~~~java
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}
public interface EmployeeFactory{
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
        switch(r.type) {
            case COMMISSIONED:
            	return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmployee(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
~~~

对于switch语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍。当然也要就事论事，有时我也会部分或全部违反这条规矩。

## 3.5 使用描述性的名称

给每个私有方法取个同样具有描述性的名称。好名称的价值怎么好评都不为过。函数越短小、功能越集中，就越便于取个好名字。

别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。

别害怕花时间取名字。你当尝试不同的名称，实测其阅读效果。在Eclipse或IntelliJ等现代IDE中改名称易如反掌。使用这些IDE测试不同名称，直至找到最具有描述性的那一个为止。

选择描述性的名称能理清你关于模块的设计思路，并帮你改进之。追索好名称，往往导致对代码的改善重构。

命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。

## 3.6 函数参数

最理想的参数数量时零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）——所以无论如何也不要这么做。

参数不容易对付。它们带有太多概念性。所以我在代码范例中几乎不加参数。

从测试的角度看，参数甚至更叫人为难。想想看，要编写能确保参数的各种组合运行正常的测试用例，是多么困难的事。如果没有参数，就是小菜一碟。如果只有一个参数，也不太困难。有两个参数多于两个，测试覆盖所有可能性的组合简直让人生畏。

输出参数比输入参数还要难以理解。读函数时，我们惯于认为信息通过参数输入函数，通过返回值从函数中输出。我们不太期望信息通过参数输出。所以，输出参数往往让人苦思之后才恍然大悟。

### 3.6.1 一元函数的普遍形式

向函数传入单个参数有两种极普遍的理由。你也许会问关于那个参数的问题，也可能是操作该参数，将其转换为其他什么东西，再输出之。这就是读者看到函数时所期待的东西。你应当选用较能区别这两种理由的名称，而且总在一致的上下文中使用这两种形式。

还有一种虽不那么普遍但仍极有用的单参数函数形式，那就是事件（event）。在这种形式中，有输入参数而无输出参数。程序将函数看作一个事件，使用该参数修改系统状态。小心使用这种形式。应该让读者很清楚地了解它是个事件。谨慎地选用名称和上下文语境。

尽量避免编写不遵循这些形式的一元函数。对于转换，使用输出参数而非返回值令人疑惑。如果函数要对输入参数进行转换操作，转换结果就该体现为返回值。

### 3.6.2 标识参数

标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为true将会这样做，标识为false则会那样做！

### 3.6.3 二元函数

有两个参数的函数要比一元函数难懂。例如，writeField(name)比writeField(outputStream, name)好懂。

尽管两种情况下意义都很清楚，但第一个只要扫一眼就明白，更好地表达了其意义。第二个就得暂停一下才能明白，除非我们学会忽略第一个参数。而且最终那也会导致问题，因为我们根本不该忽略任何代码。忽略掉的部分就是缺陷藏身之地。

当然，有些时候两个参数正好。例如Point p = new Point(0, 0);就相当合理。笛卡尔点天生拥有两个参数。

二元函数不算优劣，而且你当然也会编写二元函数。不过，你得小心，使用二元函数要付出代价。你应该尽量利用一些机制将其转换成一元函数。例如，可以把writeField方法写成outputStream的成员之一，从而能这样用：outputStream.writeField(name)。或者可以把outputStream写成当前类的成员变量，从而无需再传递它。还可以分离出类似FieldWriter的新类，在其构造器中采用outputStream，并且包含一个write方法。

### 3.6.4 三元函数

有三个参数的函数要比二元函数难懂得多。排序、琢磨、忽略的问题都会加倍体现。

另一方面，这里有个并不那么险恶的三元函数：assertEquals(1.0, amount, .001)。虽然也要费点神，还是值得的。得到“浮点值的等值是相对而言”的提示总是好的。

### 3.6.5 参数对象

如果函数看起来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。例如下面两个声明的差别：

~~~java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
~~~

从参数创建对象，从而减少参数数量，看起来好像是在作弊，但实则并非如此。当一组参数被共同传递，就像上例中的x和y那样，往往就是该有自己名称的某个概念的一部分。

### 3.6.6 参数列表

有时，我们想要向函数传入数量可变的参数。例如，String.format方法：

~~~java
String.format("%s worked %.2f hours", name, hours);
~~~

如果可变参数像上例中那样被同等对待，就和类型为List的单个参数没什么两样。这样一来，String.format实则是二元函数。下列String.format的声明也很明显是二元的：

~~~java
public String format(String format, Object... args)
~~~

同理，有可变参数的函数可能是一元、二元甚至三元。超过这个数量就可能要犯错了。

### 3.6.7 动词与关键字

给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如,write(name)就相当令人认同。不管这个"name"是什么，都要被“write”。更好的名称大概是writeField(name)，它告诉我们，“name”是一个“field”。

最后那个例子展示了函数名称的关键字（keyword）形式。使用这种形式，我们把参数的名称编码成了函数名。例如，assertEqual改成assertExpectedEqualsActual(expected, actual)可能会好些。这大大减轻了记忆参数顺序的负担。

## 3.7 无副作用

副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时它会把变量搞成向函数传递的参数或是系统变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。

参数多数会被自然而然地看作是函数的输入。如果你编过好些年程序，我担保你一定被用作输出而非输入的参数迷惑过。例如：

~~~java
appendFooter(s);
~~~

这个函数是把s添加到什么东西后面吗？或者它把什么东西添加到了s后面？s是输入参数还是输出参数？稍许花点时间看看函数签名：

~~~java
public void appendFooter(StringBuilder report)
~~~

事情清楚了，但付出了检查函数声明的代价。你被迫检查函数签名，就得花上一点时间。应该避免这种中断思路的事。

在面向对象之前的岁月里，有时的确需要输出参数。然而，面向对象语言中对输出参数的大部分需求已经消失了，因为this也有输出函数的意味在内。换言之，最好是这样调用appendFooter：

~~~java
report.appendFooter();
~~~

普遍而言，应避免使用输出参数。如果函数必须要修改某种状态，就修改所属对象的状态吧。

## 3.8 分隔指令与询问

函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。

真正的解决方案是把指令与询问分割开来，防止混淆的发生。

## 3.9 适用异常替代返回错误码

另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化

### 3.9.1 抽离Try/Catch代码块

最好把try和catch代码块的主体部分抽离出来，另外形成函数。

### 3.9.2 错误处理就是一件事

函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。这意味着（如上例所示）如果关键字try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finally代码块后面也不该有其他内容。

### 3.9.3 Error.java依赖磁铁

返回错误码通常暗示某处有个类或是枚举，定义了所有错误码。

~~~java
public enum Error {
    OK,
    INVALID,
    NO_SUCH,
    LOCKED,
    OUT_OF_RESOURCES,
    WAITING_FOR_EVENT;
}
~~~

这样的类就是一块**依赖磁铁**（dependency magnet）：其他许多类都得导入和使用它。当Error枚举修改时，所有这些其他的类都需要重新编译和部署。（那些以为可以不重新编译和部署就扬长而去的家伙最终都自尝恶果。）这对Error类造成了负面压力。程序员不愿增加新的错误代码，因为这样他们就得重新构建和部署所有东西。于是他们就复用旧的错误码，而不添加新的。

使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。（这也是开放闭合原则（OCP）的一个范例）。

## 3.10 别重复自己

重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。例如，全部考德（Codd）数据库范式都是为消灭数据重复而服务。再想想看，面向对象编程是如何将代码集中到基类，从而避免了冗余。面向方面编程（Aspect Oriented Programming）、面向组件编程（Component Oriented Programming）多少也都是消除重复的一种策略。看来，自子程序发明以来，软件开发领域的所有创新都是在不断尝试从源代码中消灭重复。

## 3.11 结构化编程

有些程序员遵循Edsger Dijkstra的结构化编程规则。Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个return语句，循环中不能有break或continue语句，而且永永远远不能有任何goto语句。

我们赞成结构化编程的目标和规范，但对于小函数，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。

所以，只要函数保持短小，偶尔出现的return、break或continue语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto只在大函数中才有道理，所以应该尽量避免使用。

## 3.12 如何写出这样的函数

写代码和写别的东西很像。在写论文或文章时，你先想什么就写些什么，然后再打磨它。

我并不从一开始就按照规则写函数。我想没人做得到。

# 第4章 注释

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

我为什么要极力贬低注释？因为注释会撒谎。注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。原因很简单。程序员不能坚持维护注释。

程序员应当负责将注释保持在可维护、有关联、精确的高度。我同意这种说法。但我更主张把力气用在写清楚代码上，直接保证无需编写注释。

## 4.1 注释不能美化糟糕的代码

带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样得多。与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码。

## 4.2 用代码来阐述

很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可。

## 4.3 好注释

### 4.3.1 法律信息

### 4.3.2 提供信息的注释

有时，用注释来解释基本信息也有其用处。例如，以下注释解释了某个抽象方法的返回值：

~~~java
// Returns an instance of the Responder being tested.
protected abstract Responder reponderInstance();
~~~

这类注释有时管用，但更好的方式是尽量理由函数名称传达信息。比如，在本例中，只要把函数重新命名为responderBeingTested，注释就是多余的了。

### 4.3.3 对意图的解释

有时，注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。

### 4.3.4 阐释

有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。通常，更好的方法是尽量让参数或返回值自身就足够清楚；但如果参数或返回值是某个标准库的一部分，或是你不能修改的代码，帮助阐释其含义的代码就会有用。

加倍小心地确认注释正确性。

### 4.3.5 警示

有时，用于警告其他程序员会出现某种后果的注释也是有用的。

### 4.3.6 TODO注释

有时，有理由用//TODO形式在源代码中放置要做的工作列表。在下例中，TODO注释解释了为什么该函数的实现部分无所作为，将来应该是怎样。

~~~java
//TODO-MdM these are not needed
// We expect this to go away when we do the checkout model
protected VersionInfo makeVersion() throws Exception {
    return null;
}
~~~

TODO 是一种程序员认为应该做，但由于某些原因目前还没做的工作。无论TODO的目的如何，它都不是在系统中留下糟糕的代码的接口。

如今，大多数好IDE都提供了特别的手段来定位所有TODO注释，这些注释看来丢不了。你不会愿意代码因为TODO的存在而变成一堆垃圾，所以要定期查看，删除不再需要的。

### 4.3.7 放大

注释可以用来放大某种看来不合理之物的重要性。

### 4.3.8 公共API中的Javadoc

没有什么比被良好描述的公共API更有用和令人满意的了。标准Java库中的Javadoc就是一例。没有它们，写Java程序就会变得很难。

如果你在编写公共API，就该为它编写良好的Javadoc。

## 4.4 坏注释

### 4.4.1 喃喃自语

任何迫使读者查看其他模块的注释，都没能与读者沟通好，不值所费。

### 4.4.2 多余的注释

读这段注释花的时间没准比读代码花的时间还要长。

### 4.4.3 误导性注释

### 4.4.4 循规式注释

所谓每个函数都要有Javadoc或每个变量都要有注释的规矩全然是愚蠢可笑的。这类注释徒然让代码变得散乱，满口胡言，令人迷惑不解。

### 4.4.5 日志式注释

有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。

很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。

### 4.4.6 废话注释

### 4.4.7 可怕的废话

### 4.4.8 能用函数或变量时就别用注释

### 4.4.9 位置标记

如果标记栏不多，就会显而易见。所以，尽量少用标记栏，只在特别有价值的时候用。如果滥用标记栏，就会沉没在背景噪音中，被忽略掉。

### 4.4.10 括号后面的注释

有时，程序员会在括号后面放置特殊的注释，如代码清单4-6所示。尽管这对于含有深度嵌套结构的长函数可能有意义，但只会给我们更愿意编写的短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的是缩短函数。

~~~java
public class wc {
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String line;
        int lineCount = 0;
        int charCount = 0;
        int wordCount = 0;
        try {
            while((line = in.readLine()) != null) {
                lineCount++;
                charCount+=line.length();
                String words[] = line.split("\\W");
                wordCount += words.length;
            } // while
            System.out.println("wordCount = " + wordCount);
            System.out.println("lineCount = " + lineCount);
            System.out.println("charCount = " + charCount);
        } // try
        catch (IOException e) {
            System.err.println("Error:" + e.getMessage());
        } // catch
    } // main
}
~~~

### 4.4.11 归属与署名

源代码控制系统非常善于记住是谁在何时添加了什么。没必要用那些小小的签名搞脏代码。

### 4.4.12 注释掉的代码

我们已经拥有优良的源代码控制系统如此之久，这些系统可以为我们记住不要的代码。我们无需再用注释来标记，删掉即可，它们丢不了。我担保。

### 4.4.13 HTML注释

源代码注释中的HTML标记是一种厌物。如果注释将由某种工具（例如JavaDoc）抽取出来，呈现到网页，那么该是工具而非程序员来负责给注释加上合适的HTML标签。

### 4.4.14 非本地信息

假如你一定要写注释，请确保它描述了离它最近的代码。别在本地注释的上下文环境中给出系统级的信息。以下面的Javadoc注释为例，除了那可怕的冗余之外，它还给出了有关默认端口的信息。不过该函数完全没控制到那个所谓默认值。这个注释并未描述该函数，而是在描述系统中远在他方的其他函数。当然，也无法担保在包含那个默认值的代码修改之后，这里的注释也会跟着修改。

### 4.4.15 信息过多

别在注释中添加有趣的历史性话题或者无关的细节描述。

### 4.4.16 不明显的联系

注释及其描述的代码之间的联系应该显而易见。如果你不嫌麻烦要写注释，至少让读者能看着注释和代码，并且理解注释所谈何物。

### 4.4.17 函数头

短函数不需要太多描述。为只做一件事的短函数选个好名字，通常要比写函数头注释要好。

### 4.4.18 非公共代码中的Javadoc

虽然Javadoc对于公共API非常有用，但对于不打算作公共用途的代码就令人厌恶了。为系统中的类和函数生成Javadoc页并非总有用。

### 4.4.19 范例

# 第5章 格式

## 5.1 格式的目的

先明确一下，代码格式很重要。代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。

或许你认为“让代码能工作”才是专业开发者的头等大事。然而，我希望本书能让你抛掉那种想法。你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。即便代码已不复存在，你的风格和律条仍存活下来。

## 5.2 垂直格式

短文件通常比长文件易于理解。

### 5.2.1 向报纸学习

源文件也要像报纸文章那样。名称应当简单且一目了然。

### 5.2.2 概念间垂直方向上的区隔

几乎所有的代码都是从上往下读，从左往右读。每行展现一个表达式或一个子句，每组代码行展示一条完整的思路。这些思路用空白行区隔开来。

### 5.2.3 垂直方向上的靠近

如果说空白行隔开了概念，靠近的代码行则暗示了它们之间的紧密关系。所以，紧密相关的代码应该互相靠近。

### 5.2.4 垂直距离

关系密切的概念应该互相靠近。显然，这条规则并不适用于分布在不同文件中的概念。除非有很好的理由，否则就不要把关系密切的概念放到不同的文件中。实际上，这也是避免使用protected变量的理由之一。

对于那些关系密切、放置于同一源文件中的概念，它们之间的区隔应该成为对相互的易懂度有多重要的衡量标准。应避免迫使读者在源文件和类中跳来跳去。

**实体变量**应该在类的顶部声明。这应该不会增加变量的垂直距离，因为在设计良好的类中，它们如果不是被该类的所有方法也是被大多数方法所用。

关于实体变量应该放在哪里，争论不断。在C++中，通常会采用所谓“**剪刀原则**”（scissors rule），所有实体变量都放在底部。而在Java中，惯例是放在类的顶部。没理由去遵循其他惯例。重点是在谁都知道的地方声明实体变量。大家都应该知道在哪儿能看到这些声明。

**相关函数**。若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。这样，程序就有个自然的顺序。若坚定地遵循这条约定，读者将能够确信函数声明总会在其调用后很快出现。

**概念相关**。概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短。

### 5.2.5 垂直顺序

一般而言，我们想自上向下展示函数调用依赖顺序。也就是说，被调用的函数应该放在执行调用的函数下面（Pascal、C和C++等语言中完全不同，在这些语言中，函数应该在被调用之前定义，至少是声明）。这样就建立了一种自顶而下贯穿源代码模块的良好信息流。

## 5.3 横向格式