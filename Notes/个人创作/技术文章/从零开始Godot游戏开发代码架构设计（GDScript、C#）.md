# 0 前言

大家好，这里是 ZeromaX訸。我之前从零开始用 Godot 做游戏的系列视频，按实际工作量天数计算已经有 230 来天。而真正做 Godot 游戏开发（GDScript / C# / F#）从 2022 年接触 3.5 开始到现在 4.4 版本，则可以算是有 3 年了（可以看出这个时间就虚一点了，中间有很多没有实际工作量的时间，哈哈哈）。

所以，在这个时间点，打算写这样一篇文章，把我所有中间开发的代码、架构设计经验做个阶段性的总结，分享给大家，供批判性参考。原因也是我自己看相关视频、文章往往都是零零星星的不够全面（这也包括我自己做的视频，讲的非常分散），而评论区，又往往因为这种只言片语的叙述，容易理解偏各种代码、架构设计知识的用意；所以我就打算先来抛砖引玉了。

文章将以我当前正式开发中的代码量已超过万行，且将继续开发的开源项目——一款观测和干预星球文明发展的放置战略游戏（GitHub 开源仓库：ZeromaXHe/ZeromaX-s-Playground）——当中实际用到的代码、架构设计为参考，辅以我自己之前的开发经验、接触过的游戏功能场景，结合实际问题，带大家把从微观代码组织，到宏观架构设计的各种方面知识都聊一聊。

因为我自己虽然有几年 Java 开发工作经历，但 Godot 游戏开发资历尚浅，甚至都不是计算机相关专业毕业的，绝不敢自称权威；所以在讲解过程中，真正有价值的一部分，也是我会**指路相关领域更权威的大佬们的资料，方便大家参考和学习**。

我自己写下的内容，如果有知识性的用词、概念错误，欢迎直接指出（因为写作比较匆忙，文章一共又有大几万字，我只能尽力保证准确，但也很可能出现纰漏）；

如果关于架构设计本身有具体细节你不满意的地方，也欢迎就事论事地指出（同时也请提出你自己对相关问题讨论的建设性想法或解决方案；而不是只贬低我的内容，但不提出解决问题本身的替代方案）；

文章里面部分配图取自互联网，仅用于让读者更直观的理解抽象概念，如有侵权，请联系我删除。

而分享内容本身，也是希望大家一定要：**批判性的看待，找到对自己有帮助的部分即可**。我不是强求大家一定要按我说的做，更不是说我就一定对；而我自己的项目架构，也必然不是完美的，会在后续开发中继续完善；

尤其是这篇文章，我感觉不详细写，又讲不完这样一个大话题；而过于详细的话，感觉大家估计也没兴趣看。所以现在仅仅就是我自己根据既往项目开发的思考，对各种积累的代码架构设计经验的分享。不过我个人感觉，其实不少内容，结合 Godot 游戏开发本身，已经比网上常见的资料讲的深一些了，想必也能有些许帮助。

## 0.1 章节分段

接下来的具体内容的章节分段，会按照下面的大纲进行：

1. 先和辩驳一下网络上常见的关于代码、架构的容易产生误导、困惑的言论

2. 1. 盲目反对代码、架构讨论的“知识无用论”
   2. 没理解架构用意，就盲目使用的“过度设计”
   3. 摆架子吹资历的“狐假虎威”

3. 然后介绍我自己想要谈论的代码、架构设计是什么

4. 1. 定义什么是我口中的“微观的代码设计、宏观的架构设计”
   2. 为什么要做这些代码、架构设计
   3. 这些代码、架构设计相关的关键指导思想

5. 接下来就是真正聊聊从零开始，从微观到宏观的代码架构设计

6. 1. 首要问题：GDScript 还是 C#？或者我现在还没资格聊的 C++？

## 0.2 阅读建议

个人建议，**最好是在有基本的 Godot 开发基础，对基础的编程概念有所了解的前提下阅读本文**（具体就是指：起码跟一个系列教程做个“麻雀虽小五脏俱全”的小 Demo，然后在此基础上去添加一些自己的功能，从而触碰和体会到一些由于代码架构设计的不好而带来的开发不便）。

因为一些 Godot 特别基础的开发、编程概念（比如什么是场景、什么是节点、什么是类、什么是函数这种）我就不会去解释了，**标题里的“从零开始”，是指如果你对架构设计相关的内容没有概念，可以从“零”代码架构知识开始**；而如果你对 Godot 游戏开发本身的基础概念都不清楚的话，看这篇文章估计会没有什么意义。

由于文章篇幅很长，涵盖了我迄今为止所有相关话题的经验、思考，所以**建议使用 PC 或者平板电脑这些较大屏幕阅读**。

大家可以根据**《0.1》**的大纲，挑选自己需要看具体的章节，而并不需要通篇看。章节里如果有与上下文相关的话题，我会写相应章节（就和上面这样：书名号**《》**加编号 **0.1** 表示），按需跳读即可。

而且因为过程中会聊到不少相关的编程思想，如果特定术语你没听过，可以跳过，那些部分可以暂时不管，以后了解过再看也不影响；因为真正关键的思想我都会用更朴素的话语阐释一遍，把这些领会到即可。

而前面的概念讲解，因为没有代码太抽象的话，**也可以先跳到后面看具体结合代码和场景的讲解**，然后大概有印象后，再回过头来自顶而下地理解架构概念的指导意义（我个人也是比较建议这种更实用主义的读法，毕竟“Talk is cheap, show me the code!”）。

毕竟你不是来我这考试的，我这也不是什么严谨的教科书，仅仅是先按照一步一步从零开始的方式，铺垫一些基础架构知识概念，方便大家建立知识体系的同时，也方便大家后续按关键字去搜索更权威、更专业的资料。所以你有较多基础时，反方向的从后面看起：看到一个名词不懂，再往前找到对应章节补充知识——这种方式也是可行的。

好吧，接下来，就让我们从“零架构知识”开始，慢慢道来。

# 1 辩驳误导和迷惑性言论

因为我自己以往已经见识过很多网络上有很多相关话题上的误导和迷惑性言论，所以相关的言论必然也会不止一次地，在现在以及未来，出现在我的评论区或者其他网络角落。

而这些言论，又往往会给新手以误导与迷惑，所以我就在此先予以辩驳。

## 1.1 盲目排斥代码架构讨论的“知识无用论”

我自己实际体会就是——我一有视频聊代码、架构设计相关的知识，就有人说：“这些没有用！浪费时间”。其实如果这种表达，换一种方式可能更能清晰、准确、合理地，真正表达清楚他们最初看到相关警告的意思：“**代码、架构设计知识，也是有适用条件的！不是普适的！**”

**但是他们就仅仅强调不适用，而忽视了这些架构知识适用的场景**。这种时候，就变成了一种盲目的“知识无用论”了。有些人可能相对情况没那么激进，仅仅表示类似“独立游戏开发不需要代码、架构知识”之类的话语，但其实我这里也要表示反对。

**即使是做独游，个人开发者仍然可以——而且需要——讨论和学习这些知识**。虽然说独游个人开发者为了权衡策划、程序、美术等等各领域的开发权重，可能需要选择代码架构领域学习深入的程度（过于深入而不注重策划与美术，自然不可）；但这不是说你就完全不需要学习这些知识了，毕竟真正代码开发中，把项目写成 bug 改不动、难加新功能的屎山代码的梦魇，始终不能靠那些人轻飘飘的一句“你别去学那些浪费时间的架构知识” 然后自己一个人苦思冥想来解决。借鉴前人的经验还是非常有帮助的。

这一点，甚至相对权威的 Godot 游戏引擎官方文档也是鼓励大家去学习的：比如 Godot 的[**手册 - 最佳实践 - 场景组织**](https://docs.godotengine.org/zh-cn/4.x/tutorials/best_practices/scene_organization.html)，里面就提到多种解耦方式、依赖注入、各种 OOP 编程范式（SOLID、DRY、KISS、YAGNI）与场景组织间的关系。现在看不懂这些名词没关系，这将和后面我们聊的很多内容相关，大部分在后面会一一说明。

其实我对于上面这种态度，多少也还是能理解的。毕竟不进行架构设计的话（最极端的：比如微观层面，所有内容都在 Godot 的 _Ready()、_Process() 这些方法里面写不拆分；宏观层面，你直接所有内容都搞到一个场景里），那其实理论上也是能开发的（只是会很心累）。

所以对于从这个最极端屎山代码的设计，到好的架构设计之间，分布着的每一个不同经验水平的个人来说，在经验范围外的知识，就很容易轻易判断为没有意义。但我感觉，还是需要大家不卑不亢地去学习研读那些前人的经验，而不是轻易在没有学习前提下妄断结论。

## 1.2 没理解架构用意，就盲目使用的“过度设计”

此外，值得一提的一点，就是上面这种矫枉过正的态度的另一方面原因：就是因为网上总是有一些装逼犯——不是拿那些代码架构知识去真正服务于写代码，讨论技术问题本身；而是去网上打压别人，捧一踩一，类似发表一些“XX 语言、引擎、工具最好，其他都是垃圾”的言论。

这种时候，甚至他们自己都还没完全理解（有的恶劣的键盘侠甚至连代码都没写过），就开始言之凿凿地以其昏昏使人昭昭了。

对应到代码、架构的知识领域，那就很容易在炫技的时候，盲目套用各种架构的代码示例本身，而忽视了它们真正想要解决的问题。从而，这也就导致了“过度设计”。

所以我一直很强调的一点是：**学代码、架构知识，理解它们的思想，提高自己代码架构品味，而不是一味地去套用代码**。

如果没做好这一点，那像设计模式、领域驱动设计（DDD）、整洁架构等等这些概念，其实都算是有不少值得学习；但因为被很多面试八股文对一些简单代码“过度设计”而滥用，所以单看那些解析，就容易变成很多人看来恶臭不堪的存在。

**所以后面的章节里面，我就不会像那些人那样“杀鸡用牛刀”，而是会从普通场景下的简单实现，然后讲解什么时候我们要引入相关知识，然后一步步过渡到在代码量巨大时仍能方便我们开发的复杂架构**。中间结合我实际开源代码里的场景，这样具体地去聊相关内容，想必会更有帮助。

大家如果现在暂不清楚，那就可以先等等看后续细节。现在就先姑且记住，**项目初期**适用于 **KISS 法则**（Keep it Simple, Stupid——保持简单，蠢人都能懂的程度），切不可“过度设计”；但同样，这个“如无必要，勿增实体”的奥卡姆剃刀，在项目本身扩大到复杂度较高时候，你也别又倒退到**《1.1》**那里提到的一直抗拒代码架构知识的程度了。到了该用的时候，那就得“适度设计”。换句话说，那就是——“如有必要，勿不增实体”（双重否定表肯定：有必要，就请务必增加！）了~

总之前两点综合一下，就是**拒绝极端，保持适度**。

学知识肯定得学——不然你连有哪些方法可以用、什么时候用都不知道；那大项目本身的复杂度是无法逃避的，此时没有相关架构设计知识只会束手无策。

但不是说学了的知识，就都必须写到项目里——而是要在合适的场景下使用，小项目简单，就没必要刻意复杂化。

## 1.3 摆架子吹资历的“狐假虎威”

聊完两个极端，这里要补充驳斥的第三点，目的是帮助大家摆脱一些无关争执。

很多时候，网上的言论都是真真假假的。为了争个口头输赢，往往评论区也是各种摆架子吹资历，说什么：“自己大厂工作多年”，什么“我游戏开发十几年”。如此起手完以后就是一通贬低你的话，或者传授一些莫名其妙的违反常识的经验。

当然，可能他们说的是真的；但大多数时候，点开个人资料页都是些三无（无视频、无文章、无动态）账号，那大概率是“**互联网上身份都是自己给的**”。我个人建议是不要太在乎这些言论。早期我对游戏开发不熟悉时，有时候还真被唬住过，没有直接反驳，但我心底里也是留下了疑惑；后来随着我自己游戏开发经验的丰富，事实证明很多都是他们乱说的。

尤其是近些年 AI 的崛起，甚至有的人拿 AI 来装大佬（别笑，我还真在评论区碰过这种人）——甚至完全盲目听信生成式 AI 产生的文字，然后以此作为似是而非的论据来踩别人捧自己，真的很容易误导和迷惑不少新手。关于 AI 生成错误信息的问题，我这里就不多聊，搜一搜相关话题自有详细原理分析。我就简单说个大家都能懂的：“尽信书不如无书”的道理，把“书”套了个“AI”的马甲，有时候就容易看不破了。

那么如此真假难辨的互联网环境下，我们怎么不掉入否定一切的虚无主义中呢？我想很简单的就是：**根据这个人既往的实际输出来判断是否可信**。

这个人真正在公开场合（互联网、书籍）中的输出越多（视频、音频、文字），而且这些输出里面情绪性的内容越少（不能是煽动焦虑、鼓动情绪的那种人），同时受到了一定专业从业者（而不都是新手）的认可。那一般情况下，也就能对应在他们能力范围内的特定领域下，你基本能越加相信一些。

反之的各种情况，那就往往你就当作耳边风，知道有这么个人，有这么个说法就行，然后就简单听听罢了。

甚至其实对于我自己，我也是建议大家批判性的看待。所以我也一直会交待清楚我自己既往经历，然后开源项目代码，大家就能自行判断我的能力范围，决定听取哪些部分。（更不提，口说无凭，说不定我也是在拷贝别人代码、编故事凹人设呢？）

所以建议大家始终保持警惕，**一切一切，都回归到自己实践中去，回归到就事论事的讨论中去**。那些老是想着摆架子、吹资历，然后总想着争个高下的人，大可别太放在心上。

# 2 所谓代码架构知识（定义、目的、核心思想）

先驳斥完一些常见误导性言论，接下来就可以认真聊聊，我想要分享和表达的内容是什么了。

首先那就需要聊一下：我前面提到的“代码架构知识”这些字词对应的真实含义——它们具体在表达什么。

## 2.1 什么是“代码架构”？

要说它“是”什么之前，需要强调的是它“不是”什么。

1. **不是用各种术语装逼**，而是**理解思想，解决实际问题**。不能因为有人教条化的装逼，就因噎废食，说那些思想本身没用。
2. **不仅仅是多人合作才能用，而是个人开发也有好处**。虽然说代码架构的好处时，经常提到多人合作的场景，那是因为他们讨论的前缀往往是“企业级”代码架构。而我这里核心在于代码架构本身，所以同样适用于多人开发和单人开发（因为你也可以把单人开发理解成不同时间、在写不同模块的自己之间进行的合作）。
3. **不是代表预先想好所有的实现内容**，**更不是对应教条式的具体框架和代码实现**（其实，如果预先能够想好所有要实现的内容，并且不再修改和新增代码的话，那反而不需要架构了），而是设计好整体实现时遵循的代码组织方式。

所以，这个“代码架构”的核心定义，其实就是指**代码的组织方式**。所以只要你写了代码，那必然就客观存在它们之间的组织关系，也就对应了一个代码架构。

那想想看，就算你什么都不学，其实随便写也是一种代码架构——只是这种代码架构会很容易出现各种问题：

- **不易阅读：**代码逻辑可能是全部挤成一团，比如什么几百行的函数、上万行的类等等。或者是嵌套过深、拆分过细，方法调用关系到处跳转，从而形成在不同文件之间循环反复的调用链条，不适合一般人类阅读（你是超人的话当我没说）。
- **不易修改：**代码同上所述——要么过于耦合杂糅，要么是过于分散——从而导致要修改功能的时候，顾虑的地方太多，直接心态爆炸。要么就是放弃思考，盲干硬干，导致没考虑关联模块，而 bug 一堆。最经典也是最可怕的特征就是：改一个 bug，出现更多的 bug！
- **不易新增**：当旧代码乱成一堆时，你写新功能时，即使有类似能够复用的逻辑，估计也不愿意去翻找这些屎山代码的。那么也就意味着你要么从头把这些类似的逻辑又重写一遍，要么就得硬着头皮去看看怎么修改旧代码让你用上类似的逻辑（修改？那就又要面对上面的问题了！）
- **不易测试**：当代码一团乱麻时，往往我们想单独测试其中一段逻辑是否正确，也是非常困难。因为前提就是你能把这段逻辑从各种不相干的部分中拆分出来（前面已经说明了：这得费很大劲）……那你会想：要测试就得一起运行测呗，看看没问题就行了！那就请问，此时往往你只能看到第一个报错崩溃的错误，假如项目已经足够庞大，而你这次大功能需求改动了大量代码，那你看到的错误背后，很可能还有几个、几十个、几百个、甚至上千个错误等着你。你是打算一个一个地排查吗？愿你长寿~
- **不易合作**：正如开头所言，这里的合作当然包括了多人之间的合作，但也包括自己和自己在不同时间下、不同模块中的合作。差的代码架构设计，往往因为以上各种因素加在一起，使得这种合作变得艰难——**不易阅读**意味着几乎所有参与者必须同时理解全部代码才能修改代码；**不易修改、不易新增**意味着每个人、以及不同时间的自己都在无时不刻往项目中埋下地雷、并做着重复的无用功；**不易测试**意味着大家都得等待着其他人的功能完成了才能测试（一个人则是得写完功能内的全部代码才能一起测），然后等第一个暴露的问题出现，开始甩锅，然后反复修改，搞得加班身心俱疲。

那么我们聊相关知识，其实就是学习不同前辈程序员，他们为了解决以上这些问题的思考。

而且对于很多看似不是“代码”的东西，也是存在这个“代码架构”，能够受益于这些知识的：

- 比如一些**图形可视化的游戏开发工具**——在 Godot 里，可以是用可视化连线来写着色器功能的 Visual Shader。类似还有一些 Godot 社区的替代 GDScript、C# 来写节点脚本的可视化工具。这些对应到 Unreal 引擎里面，那就是蓝图这种。
- 还有 Godot 的**场景树中节点的组织**。这点在《1.1》中已经链接了 Godot 官方的讲解，而我们也会在后面具体聊到如何应用相关代码架构思想来帮助我们组织场景树的节点层级顺序。

之所以如此，是因为：**你只要设计复杂的、带逻辑的流程，就必然需要一套方法论来让你有效组织这些流程**，否则就是一样会有上面提到过的毛病。而一般意义上的代码，只是流程的一种表现形式。那么，代码架构的知识与思想，其实就是对应组织流程设计的方法论，自然就能让你更好组织类似的情况。

所以自然而然，在此基础上，很多类似于前文提到的“独立游戏开发不需要架构”的言论也是不攻自破了。（除非你是自己天马行空想点子，然后拉一帮入世未深的大学生实习生帮你实现；毕竟自己十指不沾阳春水，完全不用摸游戏引擎，以上问题就都没有啦~ 反正加班熬夜没头发的是这些手底下的人，对吧？老板？）

## 2.2 好代码架构的目的

那我们总结一下进行好的代码架构的目的——从代码架构延申出来的各种知识和概念，自然不是开发者们“吃饱了没事”，而是希望能够更好的组织代码，让代码更加：

- **容易阅读**：这里常说的，是在团队配合时，方便让别人看懂实现的功能。但有些人敝帚自珍，还生怕自己的代码被别人看懂，说要搞故意写复杂让别人看不懂。那我也有一个不可否认的现实来驳斥这种观点：项目一大、时间一长，自己写的代码都会忘记。所以好的代码架构，是于人于己都好的。这就是常说的**可读性**。
- **容易修改**：好代码架构，能减少代码之间不必要耦合，从而减少修改代码时要考虑的相关代码（也就是常说的降低心智负担）。也能避免改功能实现时牵扯大量相关代码也同时修改的情况。在没有 bug 时，能减少写出 bug 的可能；在修改 bug 时，方便快速定位 bug 位置。这也是常说的**可维护性、可重构性、健壮性、灵活性**。
- **容易新增**：增加新功能，一方面也是享受前面说的便利，不会因为加功能牵扯到其他模块，而意外破坏了原有的功能，从而带来 bug；另一方面就是能快速利用起能复用的、相似的、以前写过的功能。这也就是常说的**可复用性、扩展性**。
- **容易测试**：合理的拆分和架构设计，使得我们的代码在方法、类的层级上都能够单独测试（即常说的**单元测试**）。从而不必等到把全部功能一股脑写完，整体运行时才能测试并一个一个排查 bug，而是在写完一个方法、类时就能直接测试。这也就是常说的**可测试性**。
- **容易合作**：优秀的代码架构，因为清晰的结构，自然适合多人合作。即使是单人开发，不同功能模块之间的配合与开发也变的更容易了。更具体来说，那就是减少代码和代码之间的冲突，相关问题都更容易解决。这些体现在版本控制工具更少冲突、容易合并，多线程代码不容易相互线程冲突等等。

那么同样反过来，可以说**有这些特征才是好的代码架构**。这里回过头来，大家也就能理解和判断什么是“过度设计”了——如果架构设计的结果，让你忙乎半天，结果上面四点好处一条没占上，那就是“过度设计”了。同样，不能因为架构本身看上去有些复杂的设计，你一时没理解，就说架构是“过度设计”——因为它可能是在更大维度上为了容易修改、新增、测试之类的，而且有的是在你理解思路以后，本身可读性也并没有真正损失（说不定有的还更高）。

正如**《2.1》**开头所说，**这些好处，也就主要是在项目持续的维护过程（修改旧功能和开发新功能）中体现**。如果你能预先设计好全部项目最终形态，那这些所谓好架构也就不需要了。但问题就是除了那些小的可怜的项目，大部分项目都是在维护周期中不断迭代开发的，而不能像说的那样一步到位。这种“不需要架构知识”的空中楼阁，也就只能停留在想象中了。所以想要达成易读、易改、易写、易测的目的，一个好代码架构还是非常有必要的。

## 2.3 好代码架构的核心思想

那么上面说的依然是很虚的好处，而没有真正提到具体的做法。这些具体落地代码，我们会在后文中一个一个慢慢讲解。但在开头，有必要交代一些最基础的指导这些代码落地的经典编程思想。

### 2.3.1 依赖、解耦（高内聚低耦合）

首先就是需要理解“依赖”和“解耦”两个词。前面的内容里我刻意尽量没有使用这两个术语，聊到这里，我们可以来解释一下了。

“依赖（Dependency）”我不想用太多复杂的术语来解释，想看那些的可以自行搜索。我个人感觉网上很多说法都是要么有问题，要么不好理解。在我这里让大家理解的话，那判断依据很简单：**就是指你在 A 代码层级里写了 B 的名字，那就是 A 依赖 B**。（需要注意，这里**不**包括用字符串写 B 名字这种字面上的情况）

什么意思？开始举例！

1. 比如 A() 是一个函数，它里面**调用**了 B() 函数——写了 B 函数的名字，你就可以叫作 A 函数依赖于 B 函数。
2. A(B b) 函数有个**入参** b，类型为 B 类；同样**出参类型**也是同理——写了 B 类的名字，你就可以叫它 A 函数依赖于 B 类。
3. A 类**继承**了 B 类——得写 B 类的名字，你可以说 A 类依赖于 B 类。
4. A 类的代码里出现了 B 类，比如 A 类**组合的字段、属性**，或者**函数入参、出参**里写了 B 类——这时也你可以说 A 类依赖 B 类
5. C# 里面还有接口这个概念，那就还有 A 类**实现**了 B 接口这类情况——也是 A 类依赖 B 接口

在此基础上，这种“依赖”，我们也可以替换的称之为**“强耦合”**。这往往是我们的 A 需要让 B 帮我们做些事情的情况，比如我们前面说的调用函数、继承类型、实现接口，以及组合的字段、属性、出入参等等。

但还有一种情况下，我们称为**“弱耦合”**，对应就是：我们的 A 不需要写 B 的名字，就能让他干活！从“强耦合”变成“弱耦合”的过程，我们也就称之为**“解耦”**。

猛地一看还挺神奇，其实我举例说一下，对应到我们 Godot 游戏开发中是哪些场景，你就明白了：

1. **连接信号**。如果我们在编辑器里把 A 类的信号连接到 B 类的方法，或者由一个 C 类来用代码绑定 A、B 间的信号，那 A、B 之间就解耦了。

2. 1. 在 C# 里那有个和 Godot 信号类似功能的概念，叫做**事件（event）**。那也可以用来解耦。

3. **lambda 和 Callable**。这个估计有些 Godot GDScript 新手以及 C# 新手都没接触过，在编程语言的领域下，有时也叫做**匿名函数、方法引用。**它们也能用于解耦

4. 1. 在 C# 里有对应的**委托（delegate）**概念，还有它自己的 **lambda 表达式**，同样也能用来解耦

5. **序列化和反序列化**。这个就是一种更加特殊场景下会用到的解耦手段，通常是数据传输、或者持久化存储到硬盘时才会用到，一般情况下不会单独为了解耦这样做，但客观情况是有时这样以后确实解耦了。对应意思，可以简单理解为：我把类保存成字符串或者最原始的字节格式文件（这称为序列化），然后另一边用这个字符串或者字节流、文件还原出需要的数据（这称为反序列化）。游戏开发里的常见场景就是那种程序设计好，直接给策划配的 json、csv 表文件。

6. GDScript 常用的手段：**动态类型、鸭子函数**。GDScript 是允许我们不写出变量的类型的，所以这也确实是一种解耦的手段。但问题是 GDScript 的动态类型是弱类型，所以不太建议过度使用该方法解耦（在接下来的**《2.3.2》**中我们会进一步详细解释），使用时，请考虑先用 has_method() 判断一下方法是否存在。

7. 1. 与之配合的，是 Godot 有大量用字符串表示路径、分组，进而获取依赖的办法。配合动态类型，这样也能解不少强耦合。但是需要指出的是，依赖字符串实现功能是种不好的代码风格，具体原因也将在**《2.3.2》**说明。
   2. 类似功能，C# 其实也有 **var** 和 **dynamic** 两个关键字。区别和用法我们也将在后面**《2.3.2》**讲解，这里可以记住，它们可以用来实现类似动态类型的功能，从而解耦。

8. C# 特有的常用手段：**接口（interface）**。通过使用接口，我们可以使得两个类型之间解耦。取而代之的是一个类型 A 实现接口 IA，另一个类型 B 用接口 IA 来代表并操作 A。

其实《1.1》里面“场景组织”官方文档开头也提到了

### 2.3.2 编译期、运行期（让问题在编译期暴露）

前面提到各种解耦的方法，但是我中间特意强调了一些方法是不好的，不能为了解耦而一味的去用那些方法。这是为什么呢？那我们就得引出第二个判断好代码架构的核心思想了：**尽量让问题在编译期暴露，而不是运行期**。

要理解这个，那我们得首先理解：什么是编译期？什么是运行期？

首先**编译期**。

对于 C# 很好理解，因为 Godot .NET 版有个单独的“编译”按钮，而且每次运行前都会编译 C# 代码，这种时候报错了就自然算是在编译期暴露的问题。

而对于 GDScript 这种解释型语言，连编译按钮都没有，改了代码就能生效，它有所谓编译期吗？也是有的。你可以理解为，这里的编译期，其实就是指在我们游戏程序还没运行时。包括前面说的 C# 主动点击编译时的报错，也包括你 C#、GDScript 还在编辑过程中，这时写错了，编辑器内会进行报错或者警告，指出问题；以上这些，我们就都称之为问题在编译期暴露出来了。简而言之，就是不需要运行游戏就能查出错误。

反之，**运行期**，那就是指游戏程序真正运行起来之后的阶段。

那为什么要让问题在编译期暴露呢？道理很简单：

1. 首先，最明显的，少了运行游戏这个步骤，早点把问题暴露就能早点解决。
2. 其次，如果问题出在了运行期，你就往往需要使用调试功能，排查整个程序的状态（各个变量、字段、属性当前是什么值），看看是哪个导致了问题。当程序状态很复杂（变量、字段、属性很多，调用流程步骤繁琐）的时候，这是非常痛苦的事情。
3. 而如果能够把问题暴露在编译期，则往往走读代码就能轻松解决。

对应的具体典型情况就是空指针（或者 C# 叫空引用）异常，原因就是 null 带来的运行时问题。该问题在 GDScript 下就只能在运行期解决；但是 C# 中就有相应的空引用检查 Nullable 功能，能把问题提前到编译期。这也是 C# 优于 GDScript 的一个细节。

回到前面提到的不好的解耦办法，你就会发现，它们共同的特点就是把问题推到运行时才能暴露。

### 2.3.3 有向无环图（依赖方向、控制流方向）

然后说完以上这些，我们虽然知道了要解耦，以及比较好的解耦方式，但是具体应该按什么规则、什么层级、什么粒度来进行解耦，依然很难思考。如果错误想象成了把所有看见的外部类名、外部函数名都解除掉，那就走上一条极端的，不可实现的道路。所以这里我需要指出第三点好代码架构的核心思想：**让你的依赖方向、控制流方向形成有向无环图**。

有人可能就要骂街了：“你这说的还是人话吗？全是汉字为啥我开始一个字都看不懂了！” 不着急，我还是一个一个解释一下含义。

**依赖方向**比较好理解，依赖就是上面**《2.3.1》**说的依赖（A 写了 B 的名字 = A 依赖 B），加了个方向，就是说 A 依赖 B，相当于你在一张图上写下 A 和 B，然后画一根线从 A 指向 B，这根线就是代表依赖方向。

**控制流方向**比较难理解。它其实就是说我们的方法（类的函数）的调用方向也会形成一个方向，这个 A 调用 B、B 调用 C 的过程，我们称为**控制流**，表示调用的走向。（相类似的概念还有**数据流**，表示数据走向，这个就简单提一下，我们先不细说。）

最后的**有向无环图**是什么呢？

那**有向**比较好理解，依赖方向和控制流方向都是有方向的。

**图**，简单来说是指我们的类很多，又不是排成一列的“链表”、或者共有一个根节点的“树”的这些形式，在数据结构上一般归属于“图”这种类型。（看不懂不纠结，这里不是重点）

重点在于**无环**。就是这些方向你不能形成一个循环。

这里的意思具体来说就是两点：

1. A 依赖 B 的话，你就不能让 B 也依赖 A 了。而更复杂的依赖情况 A -> B -> C，你也不能让 C 依赖回 A。以此类推，A -> B -> …… -> N，禁止 N 依赖回前面所有的。（简称为**禁止循环依赖**）
2. 同理把上面文字中的“依赖”换成“调用”，即可表示控制流方向的有向无环图的意思。（简称为**禁止循环调用**）

通过这种方式组织代码，会让我们的代码更加清晰易读：因为层级主次分明，不会出现循环，所以不会出现分不清入口，或者读代码时把自己绕晕的情况。

这里对于可能出现的比较特殊的情况，提前简单说明一下：

1. 对于依赖，会有**相互依赖**的情况需要处理。这里我们就能直接用上前面**《2.3.1》**各种解耦的办法处理，保证只有两个类之间只有单方向的强耦合，另一个方向上则只进行弱耦合。
2. 对于控制流，会有**递归调用**的正常情况。这里我们尽量让递归只出现在单个类文件中（我们称之为**自递归**），这种情况我们是允许的；但如果有跨两个（或多个）类的方法递归调用（我们称之为**相互递归**），这种情况可以考虑使用“**蹦床函数（trampoline）**”来将递归写到一个类文件中，从而避免跨类文件的递归。（相关内容，我最初是在《Scala 与 Clojure 函数式编程模式》“模式 13 相互递归模式”学到的，不知道有没有其他更普遍使用的语言的资料讲解过）

### 2.3.4 显示、逻辑、数据相分离（MVC、MVP、MVVM、DDD 等）

上一节我们提到有向无环图，但是怎么去建立这样一个有向无环图，依然缺少细节的思维指导。所以这里引出我们的第四条：**显示、逻辑、数据相分离**。简单来说，那就是我们把整个 Godot 游戏系统分为三部分，按照从上到下分别是展示层、逻辑层、数据层进行分层。

1. **显示层**负责处理用户输入与画面显示。
2. **逻辑层**负责处理具体业务逻辑。
3. **数据层**负责存储数据，以及提供数据的增删改查。

按照这个最基本的思考方式，我们就能够较为轻松的组织好我们的依赖方向和控制流方向的有向无环图：**不同层级的类之间，只允许按照既定的层级间的规则，单方向的调用、依赖**。具体来说就是规定好哪一层依赖、调用哪一层，然后里面的类就都按照这个进行设计——**不能出现**有个显示层的类 A1 依赖逻辑层的类 B1，但另一个逻辑层的 B2 却反过来依赖显示层的类 A2 这种情况。

但这里具体层级组织关系，各种不同的架构思想就会有不同的选择。

比如大家常见的 MVC、MVP、MVVM 几种模型，它们**对控制流方向进行不同设计**。

**MVC（Model-View-Controller）**因为已经被讲滥了，所以有很多种说法。有的仅是很浅的单独做到了按我们这一节的内容分三层，并没有提到控制依赖、控制流方向。这种自然没有完全领悟到精髓。

一般如果认真设计它的控制流方向的话，我这里就用 MVC 特指以下控制流向的三层模型：一般是从**控制器层**（**Controller**，大致对应我说的逻辑）开始，它能调用**视图层**（**View**，大致对应我说的显示层）和**模型层**（**Model**，大致对应我说的数据层）；然后视图层可以调用模型层。

**MVP (Model-View-Presenter)** 

**MVVM (Model-View-ViewModel)**

而 DDD 相关的一些概念，则是在**对依赖方向进行不同设计**。总体思想就是，让**更稳定、不易变化的层级，被那些容易修改的层级所依赖**，依赖方向必须要指向更稳定的方向。

**DDD**（Domain Driven Design，领域驱动设计）

数据驱动设计

### 2.3.5 重构、单元测试（代码的坏味道、测试下的安全重构）

说了这么多，那么结合前面全部四点，最后这一点核心指导思想也就非常重要了，就是：**一定要重视重构和单元测试**。

先定义一下：

- **重构**就是指重新调整你的代码组织，毕竟我们的落地代码怎么实现预想的架构，这个不是能一步到位的。而且在修改旧功能和增加新功能时，自然而然就会出现重构。
- 而**单元测试**就是指独立的用于测试你主代码的测试代码。比如我有个加法的函数 `add(a, b)`，它的单元测试，就是在看它 `add(1, 1)` 时等不等于 2（验证对特定入参的正确性），或者 `add(x, y)` 等不等于 `add(y, x)`，`add(x, add(y, z))` 等不等于 `add(add(x, y), z)`（验证是否满足加法交换律、结合律，这种测试方法称为**基于属性的测试（Property-Based Testing）**，很值得了解一下），等等

这里说重视，倒也不是说你得一天到晚把项目重构到完美状态，或者必须把所有方法都覆盖满单元测试，我个人倒是没有那么极端。

我的侧重点在于，**重视重构**是指：你得按前面四点，清楚地意思到代码里面存在的“坏味道”——临时有的地方没有设计好也是很正常的，但你得知道这些地方未来有机会你就得回来重构，所以一定最起码保证你代码的**易修改性**。（不记得怎样算是易修改，请回顾**《2.2》**）

而**重视单元测试**，是指你可以不真正写全所有单元测试的代码，但你必须保证你的代码的**易测试性**（同样参考**《2.2》**）——我想写的时候，就能随时可以补这个单元测试；或者是我在排查一段代码的 bug，我就能很快加上这个单元测试用来单独测这一段代码。

这两点说起来简单，但其实做起来并不容易，对应的你就必然不能抗拒去学习相关的知识。

像这两个话题，其实都能单拎出来写书了。重构这块我读过同名的书**《重构：改善既有代码的设计》**，非常细致的讲了如何试别代码坏味道、以及具体重构操作。大家有时间也可以去阅读一下。

而单元测试本身，则一方面会在与重构相关的话题同时出现，因为安全的重构非常依靠一套单元测试体系——为了保证重构后的代码功能和之前一样正常。另一方面各种**敏捷开发**、**测试驱动开发（TDD）**等方面的书籍也会详细介绍。也是非常值得学习的。

（顺便一提，很多人都是没去真正阅读相关书籍，单凭名字来误解这些方法、大放厥词：比如什么“像重构这样反复修改已有功能，毫无必要，能跑就行”、“敏捷开发就是快点开发，别搞乱七八糟的单元测试、架构设计之类的”、“测试驱动开发就是必须先把测试方法全部写完再开发，没有屁用”。他们说的，几乎就和那些原本的理论南辕北辙——所以我建议大家都是少听这些 XX 的话，多去看真正那些在认真思考相关问题的专著是怎么说的）

但在此，这两点具体的方法我就不细说了，后面会在落地代码讲解时具体说，其他没聊到的，大家可以去参考更权威的相关资料。我这里主要就是着重强调一下它们对于代码架构的重要性。

因为我们前面提到代码架构并不是为了提前设计好一个一成不变的系统，然后再也不去修改（**《2.1》**）；而是要在整个项目代码迭代开发的过程中不断更新的。所以**就像“流水不腐”，我们时刻保持我们的代码易于重构，那就能让我们的代码架构不腐败掉**。否则，总是想当然的写代码，不去考虑后续重构时的困难，那自然相关的代码就难修改、易固化，具体来说那就往往是会违背前面我们说的各种思想，然后耦合成一团。到那个时候，项目一大就更加不想去解决这些问题，那就真是神仙难救的屎山代码了。

（我自己最近就是差点让节点层的代码往这个方向发展，还好我做好了可重构性的各种准备，所以要重构起来还是相对容易些——只是项目本身比较大，那就会对应不少工作量。所以在此建议大家如果有机会还是能尽量做好一些适度的架构设计）

**而为了保证易于重构，最简单的判定方式就是是否好写单元测试**。好写单元测试的代码，一定是容易重构的代码。因为如果可以单独测试具体的一个个功能点、类、函数，也就意味着你这些功能点、类、函数的实现可以随意的作为一个独立单元进行移动、修改。那么如果你一开始有设计不好的地方，也能够及时调整。而前面也提到本身单元测试又让你重构更加安全（有 bug 的话，单元测试就通过不了）。

所以综上所述，我个人认为：**没必要时刻保持完美架构，以及全单元测试覆盖率；但必须重视你的代码的可重构性和可测试性**。否则代码架构必然在项目维护周期内快速走向腐败，这就是我说的“重视重构和单元测试”的含义。

### 2.3.6 补充解释：为什么要弄这么多规约与限制

虽然前面五条已经是核心指导思想的全部了，但我这里还是单独加了一节。来说说代码架构知识学习的常见困惑：**本来我们可以随心所欲地自由的写代码，为什么现在要强加这么多规约和限制**？

其实比较具体到每一条思想，之所以这样做的原因，前面都分别提到了。现在就总体在更高维度上，解释一下为什么**规约与限制其实是让我们更好地写代码**的问题。（因为这一章会涉及到更高维度上对计算机发展过程的讨论，所以如果有不熟悉的部分，可以快速跳读。）

这些规约与限制，其实并不是因为那些有经验的软件工程师都是虐待狂，故意编出来这些来让你写代码写的不爽；而是因为他们根据经验总结出来，能够预见到——在这些情况下，你“乱写一时爽”，但后期要修改旧代码、新增新功能的时候，就是“维护火葬场”了。

所以为了避免一时的爽快带来长久的未来痛苦，你需要提前遵守相关规约和限制。

（就像我们生活中，理论上在你的大脑指挥下，你的人体自由做出什么动作都可以，但我们却要去遵守道德和法律的制约。这样，你也可以把社会理解成人类的“架构”，就确实是可以类比的）

其实如果愿意了解计算机发展史的话，你就会发现很多东西都是随着计算机领域、编程语言的发展，错误的做法会慢慢在设计层面上淘汰或者规范掉。

比如 **goto 语句**这种早期计算机语言中（比如 **BASIC 语言**）可以让代码语句接下来任意跳转到任意位置的语句的功能，非常自由吧？但它就是非常经典的大坑，因为你根本不知道你的代码会被其他代码空降执行，然后这些代码又可能在后面执行的时候不知道什么地方空降到别的位置！

所以在 **C 语言**里，就限制了你只能在函数内这样跳转了，对 goto 进行了限制。像 **Java** 里就只提供嵌套 for 循环的时候通过类似功能跳到最外面的循环外，又进一步限制。

可以看出 goto 这种功能，在现在取而代之的是 **for、while、if、switch** 这些循环和条件分支语句，他们是我们现在习以为常的更规范化的用法。但你认真想想，它们是不是相比于 goto 没那么自由了？但正是这些限制让我们能写出更好维护的代码。

类似的还有**指针**这种概念，如果你仅仅是用 GDScript 语言开发 Godot 游戏，可能你都碰不到了。那这也是某种程度上限制了你的自由（直接用都不能用了！）

但目的也是通过这种限制，减少你在不懂指针相关的错误设计时，为了方便而随便乱用，从而意外给自己带来麻烦。而且一般的游戏逻辑开发，并不太需要这种底层功能，如确实有必要，那 Godot 中可以去用 C++ 写。

而在 C# 中，你不去用 unsafe 的这些底层 API，正常情况下其实也是接触不到指针的。

所以这里就是用这点说明：C#、GDScript 语言也是偷偷给你进行了限制的。

那同样，我们现在的 Godot 游戏开发中的 GDScript 语言、C# 语言，它们能称得上计算机发展的巅峰，从此以后再无缺陷？任何提供的功能，你都能随便用并且同时保证代码好维护吗？答案自然是否定的。

首先**这种让语言层面直接限制和规范你使用的过程，是非常漫长的过程**。一个 goto 的逐渐取消，就耗费了几十年，那其他问题呢？

比如像前文**《2.3.2》**讲的 C# 空引用检查把空引用问题提前到编译期的示例，null 的问题可是在计算机历史上也非常经典的问题，它的发明人霍尔（早在 1965 年！设计 ALGOL W 语言时引入了 null 这个设计）直称：“我把它叫做我的‘十亿美元错误’”。

但即便如此 C# 自己现在都不是强制性开启空引用检查功能，而 GDScript 就更加完全没有相关限制！

其次那就是**这条在语言层面让开发者代码更易维护的发展道路，起码在编程语言界目前还没看到尽头**。各种新生语言，对于这种方向的探索其实很多。我自己之前试过用来 Godot 开发的 F# 语言，其实这个角度上的不少方面就比 C# 走的更前一些。但就算是它，以及我们这篇文章主要讨论的历史更悠久的 C#，或者更年轻且专注于 Godot 的 GDScript，远远谈不上它们的功能你能随便乱用就自然而然写出好代码的程度！

所以之前有很多人在我评论区会说：“Godot、GDScript 提供什么你就用什么呗！为什么要搞得这么复杂来限制自己！” 现在请读者来帮我回答一下，你能说出理由吗？

哈哈，不过我这里还是自己来总结一下：**Godot、GDScript 确实提供了相关的功能，但并不意味着随便用就能让你的项目好维护（也就是修改旧功能、新增新代码）**——所以，怎么样是最佳实践？怎么样才能尽量避开未来可能的问题？怎么样才能设计一些良好的规范和限制来辅助我们写好代码？都是值得探讨的问题。

Godot 自己官方文档上都要专门开几篇文章来讨论这些，只是它肯定也没办法覆盖所有细节，而且 Godot 自己作为年轻的游戏引擎，也还在发展过程中。所以，还有很多细节需要社区里的大家自己去探索、交流，总结经验。这就是我们在这里讨论并设计出这些看似“碍手碍脚”的规约和限制的原因。

## 2.4 “代码知识”和“架构知识”的侧重点：微观与宏观

那么说完好代码架构的核心指导思想，后面整篇文章的主要话题，简单来说，我就会聊 Godot 游戏开发中组织代码可以用到的各种具体知识。

这里其实用我自己的语言，算是能把“代码架构知识”分为两部分：“代码知识”和“架构知识”。

我说**“代码知识”**时，可能更偏向微观代码语法层面，**“架构知识”**则偏向宏观项目架构层面。如果有看过**《代码整洁之道》**和**《架构整洁之道》**书籍的话，大概就是按这个两本书的标题与内容对应的。

在后面的章节，我也将对于 Godot 游戏开发领域的，从微观的函数、方法的代码组织，到更大维度的类、节点、功能模块之间的架构组织，进行具体讲解。

其中微观代码层面的话题我会讲的比较简略，而宏观架构层面我会相对详细说一下。原因也是聊过前者代码层面设计的人，以及可以参考的资料其实还挺多的；但后者架构层面，尤其是 Godot 游戏开发方面，全面系统的聊这个的比较少，所以我着重聊聊。

# 3 等级一：代码知识——先把微观代码组织好

那么接下来，就是我们正式在前面说的思想指导下，按照从零开始的顺序，一级一级向上设计我们的代码架构的过程了。

这里我也会分为 GDScript 和 C# 两个语言介绍，一般情况下，GDScript 的开发技巧，在 C# 内也是适用的。但反过来，C# 很多高级语言特性，GDScript 没有，所以只能用在 C# 里。

因此后面的章节，我都会先介绍 GDScript 能用的知识，再介绍 C# 特有的知识。如果仅仅使用 GDScript 的开发者，可以跳过 C# 部分；但 C# 读者也可以看看 GDScript 的部分（相关内容如果有必要，我会写一份 C# 示例）。

此外，如果你还依然在纠结 Godot 中用 GDScript 还是 C#，我在**《3.2.1》**进行了相关讨论，希望能帮助到你。感兴趣的话可以优先把那段看了。

## 3.1 GDScript 微观代码组织

其实这一点，大家可以先参考 Godot 的官方文档：[**手册 - 编写脚本 - GDScript - GDScript 编写风格指南**](https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/gdscript/gdscript_styleguide.html) ——里面已经讲的相当详细了，对于格式、命名规定、代码顺序的设计都有介绍。

我这里就着重补充一些重点以及网络上容易争议的点。

### 3.1.1 建议使用静态类型编程

这点其实大家也是优先参考 Godot 官方文档的内容：[**手册 - 编写脚本 - GDScript - GDScript 静态类型编程**](https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/gdscript/static_typing.html)

当然，动态类型并不是不能用，毕竟新手写起来更简洁方便，小项目也不会出太大问题。这些当然是它的好处。但毕竟我们这里聊的是架构知识，对应就是相对大些的项目，这此前提下，建议大家优先考虑使用 GDScript 的静态类型编程。（对应到 C#，那就是不要随意滥用 **dynamic** 这种运行时动态类型，**var** 这种编译期类型推断是鼓励多用的）

这个点，其实就是对应了我们好代码架构的指导思想之二（**《2.3.2》**），把问题尽量暴露在编译期。

对于 GDScript，通过静态类型的声明，我们可以利用起编辑器的**代码自动补全**功能，减少书写错误；同时也可以让写错的调用（类名、函数名、字段属性名）直接在**编辑器内报错**；此外还有**安全行**这种方便你检查错误的功能。如果你滥用 Godot 的动态类型，是享受不到这个好处的。

虽然静态类型需要你多敲些字，想想我前面提到的“规约和限制是为了你更好的写代码”（**《2.3.6》**），请你相信这些付出是值得的。更不必提，静态类型还能在**性能方面也带来提升**的附加好处。

以上内容均可参见于官方文档。

### **3.1.2** 不涉及 Node 功能时，优先考虑继承 Object、RefCounted；必须使用节点时，考虑使用节点池进行优化

网上非常常见的一种说法是：你在 Godot 里面，搞明白节点（Node）以及它们在场景树中的组合模式，那就够用了，其他别花里胡哨地搞那么复杂。

那很遗憾的告诉你，对于小项目开发，确实够用；但只要你想稍微扩大到大一点的项目（这并没有想象的那么“大”——可能只需要几个场景，出现了纯逻辑的复用就行），他们就又是在误导你了。

看看 Godot 编辑器内的 API 文档，就知道事情显然并没有那么简单：

- 点开 Node 类的文档，你会发现它继承了 **Object 类**。

- 而一些常用的工具类（比如 A* 算法的 AStar2D、AStar3D，还有动效常用到的 Tween），它们继承了 **RefCounted 类**

- - 而 RefCounted 类也继承了 Object 类。
  - 这个 **Object 类是 Godot 里所有类型的基类**

如果只靠节点就能完成所有功能，那 Godot 就应该把 Node 类作为基类，而不是这个 Object 类。

那么这个 Object 类和 RefCounted 类，究竟是干嘛用的？让我们一一道来。

**Object 类**，翻译成中文就是常说的“**对象**”。作为所有 Godot 类型的基类，它就是包括了 Godot 代码里类的最基本功能。具体内容可以去看它包含的方法和信号，我这里不细说。

**RefCounted 类**，这是在 Object 的基础上，增加了“**引用计数**”（就是 RefCount 的中文翻译）的功能。这个引用计数，对应是用于**垃圾回收（GC，Garbage Collection）**的——就是说当这个类的对象不再被任何其他地方引用时，我们就会把它作为垃圾回收掉。而这个引用，我们通过计数的方式去判断，就叫做“**引用计数法**”。

这里就对 C# 使用者多说几句：其实在这里就是**建议 C# 中优先考虑 C# 自己的 Object，而不是继承 Godot 的 GodotObject（对应 GDScript 中 Object 类）、RefCounted 类**的原因——因为 C# 自己的 GC 方法是比引用计数法好的，具体就不展开谈了，自行搜 C# GC 机制的底层设计即可。

引用计数法的缺陷，大概是说在特殊情况下，假如 A、B 两个对象都已经不被其他对象引用，但 A 引用了 B、B 引用了 A（具体来说就是 a 对象里面有个存储 b 对象的属性，而 b 对象同样也存了个表示 a 对象的属性），这种情况下，虽然它们没被别的对象引用，已经称为没用的需要回收内存的垃圾，但因为引用计数法里，它们各自还有一个引用，计数为 1。那么垃圾之间互相引用了的话，那引用计数法就回收不了；而因为 C# 并不是用的引用计数法做 GC，而是有更复杂的设计，因此不存在此问题

而前面被人们大吹特吹的节点，**Node 类**，则是在 Object 的基础上多了一大堆节点生命周期的方法：进入场景树时的 `_enter_tree()`、就绪时的 ` _ready()`、运行时游戏循环每帧调用的 ` _process()`、用户输入时的 `_input()`、退出场景树时的 `_exit_tree()` 等等(`_process()` 和 `_input()` 还有好几个变体)。具体可以自行去 API 文档查看相关方法与信号，远远不止我这里谈到的这些。

对应的，也就是如果你继承了节点类，对应在运行的时候，Godot 引擎得在背后多做很多工作。

那么回到标题，如果你并不需要这些功能的时候，你也直接继承 Node 类，对应的就是会**给性能带来不必要的损耗**。

以我自己的经验，在《从零开始做游戏（第217天）》（https://www.bilibili.com/video/BV18vZLY7E1T）视频里提到了，即使调用 `hide()` 方法把节点的 `visible` 属性置为 `false`（不可见），并且调用 `set_process(false)` 关闭帧处理（停止每帧执行 `_process()`），相当于让节点呆在后台；此时**这些后台不可见不处理的节点，却依然会占用每帧的处理时间**！

所以为了解决这些问题，**你并没有真正用到 Node 类相关功能，那你就不要继承 Node**。而是根据你是否需要自动垃圾回收，来**继承 Object 类或者 RefCounted 类**。前者，你就需要自己调用 free() 方法来回收内存。后者，相当于只要你不出现循环引用的情况，在它们没被用到的时候，就能自动正常被回收。

（诶？发现没有，这里又部分对应了：做到**《2.3.3》**说的“依赖方向、控制流方向需要组成有向无环图”的话，那你就自然不会被这一点坑哟！好的代码架构思想就是这么无孔不入地帮你减少 bug，哈哈哈）

你回过头去看前文，就可以观察到，像 Godot 自己提供的那些纯逻辑的工具类——A* 算法和 Tween——它们就是继承的 RefCounted。原理就是我这里说的，它们并不需要 Node 的功能，而且它们需要在使用完的时候回收掉，所以如此。

那么另一方面，如果必须是用到节点相关功能的情况，那可以考虑使用**池化思想**，类似游戏编程领域常说的“**对象池**”那样——做一个**节点池**，来回收重复利用已有节点，从而保证不生产多余的节点来占用性能。

这里我们可以用前文视频链接里，我的这个星球观测的游戏来说明。开发场景就是：因为用来表示地形分块的节点（我们称之为 Chunk）非常多，容易占用性能，所以我们引入了节点池。只显示我们视野范围内的 Chunk 节点，这样就能节约那些不可见 Chunk 节点的性能占用。

大致方法就是：在代码中声明一个数组（C# 中请使用 List 列表），就姑且命名为“节点池” node_pool，里面保存所有我们生成的 Chunk 节点。

最一开始列表是空的，第一个需要显示的节点，我们自然需要实例化（instantiate）这个节点，然后放到我们的 node_pool 数组里。然后当它需要离开视野时，我们就并不是按照一般方式 `queue_free()` 回收掉它；而是让它停止处理并不可见（`set_process(false)`、`hide()`，此外还可以清理一些无用数据），从这时开始等待一段时间，如果过完这段时间还没有新的分块要显示，再回收掉。

那如果中间有新的节点要显示，那我们就可以看看 node_pool 数组里有没有这种停止处理并不可见的节点——有的话，那我们就能复用这个节点，把相关数据配置好，重新启用。这样就节省了反复实例化和回收销毁节点的大量性能开销。

（当然这时如果没有这种后台节点了，那自然就还得继续实例化节点。所以还有一个优化技巧就是，如果你提前知道你大概要多少个节点，可以提前实例化好相应数量的后台不运行节点，那用的时候就能直接用了。这也就叫做节点池的**预热**）

通过以上方法，你在微观代码层面上做到这些，不跟随那些人云亦云地说只用节点的人的话；那就已经够保证享受节省性能损耗的好处了。而后面，我讲更高层级架构时，我们还会再次重温这里提到“节点很重”的这点，所以这点请务必注意，请合理使用节点。

### 3.1.3 SOLID 原则？很抱歉，GDScript is SOLD！

**《1.1》**中我们引用了 Godot 官方文档讲场景组织的那篇，说相关游戏开发可以参考许多架构设计思想，其中提到一个思想：**SOLID 原则**，我们这一节可以具体聊聊。（不过因为这种原则相对比较抽象，没那么多具体的代码。所以不感兴趣的可以跳过，之后章节提到了具体场景时再倒回来看也行。）

该原则本身是由 Robert C. Martin 在《敏捷软件开发：原则、模式与实践》一书较为正式的总结提出。而在他《架构整洁之道》一书中讲解该原则时前言中提到，当时 2004 年前后，有人提醒他这些原则首字母排列以后，刚好能组成 SOLID（坚固的）这个单词，所以因此也固定下了这个称呼。

那么通过上面的历史描述，很显然，这个 SOLID 原则其实是对应了五条原则。那为什么我标题里说，对于 GDScript 来说是 SOLD 呢？（哈哈哈~ 很遗憾，GDScript 不是“坚固的”，而是“被卖了”）我们就来看一下 SOLID 分别对应什么：

1. **SRP** (Single Reponsibility Principle) **单一职责原则**
2. **OCP** (Open-Close Principle) **开闭原则**
3. **LSP** (Liskov Substitution Principle) **里氏替换原则**
4. **ISP** (Interface Segregation Principle) **接口隔离原则**
5. **DIP** (Dependency Inversion Principle) **依赖反转原则**

#### 3.1.3.1 接口隔离原则（ISP）

看名字就大概知道为啥 GDScript 没有 I（对应 ISP）这个原则了——你都没接口（interface）这个概念，还想啥接口隔离呢？

但其实“**接口隔离原则**”的含义不止于编程语言的“接口”概念，Robert C. Martin 在《架构整洁之道》中对它也有其他更泛化的解释，就是说类似系统 S 引入了框架 F，F 又引入数据库 D 的情况，此时 S 依赖 F, F 依赖 D，那么 D 如果包含了上面 F 和 S 都不需要的功能，这些的修改会导致它们需要重新部署。这个问题他也归类于“接口隔离原则”下的讲解。

但是很显然，**这和我们 GDScript 也没啥太大关系**，所以我就把它择出去了。（如果你有其他看法，欢迎聊聊）

但是对于 C# 使用者来说，我们可以简单说一下 ISP 本身是什么内容。

其实也就是对应上面说的**没用到的功能，就没必要通过接口暴露出去；而多个不同使用者，最好也是根据不同的操作隔离成不同的接口**。简单说就是 A1、A2、A3 都用到了 B 类，但是分别调用 b1, b2, b3 方法；那我们与其创建一个公用的 IB 接口，不如分别创建 IB1、IB2、IB3 分别给它们使用。

（值得一提的是，有的时候这种单一方法的接口可以用 C# 的**委托、lambda**，根据场景的复杂层度不同，而替代掉；此时其实也是接口隔离原则的一种体现）

那么接下来，我们就认真聊一聊剩下四个原则。看看它们究竟什么含义，如何指导我们微观代码组织。

#### 3.1.3.2 单一职责原则（SRP）

首先是**单一职责原则（SRP）**。单看名字也是很容易误解，“单一职责，那只做一件事的话，对于函数倒好说；类的话，是不是就只能有一个函数了？！”

对于函数来说，这个理解没太大问题，它也能指导我们把大函数重构成几个小函数。但类的层级（或者 Godot 里面，也对应适用于场景组织）上，参考《架构整洁之道》的原文，需要这样理解——**任何一个软件模块都应该只对某一类行为者负责**。这里的“软件模块”，就对应我们的类文件或者 Godot 场景，总之就是一组紧密相关的函数和数据结构。

对于类来说其实还比较好理解，正常情况下，我们写代码就大概会是一个类围绕着一系列相关功能。比如玩家 `Player` 类，那就是玩家相关的各种行为，比如生命值的计算，移动和攻击等等。武器 `Weapon` 类，可能就是武器相关的各种行为，更换弹夹、武器开火等等。

唯一需要注意的，就是当这样一个类比较大的时候，比如玩家类特别庞大了，就可能就需要进一步细分成玩家生命值管理类 `PlayerHpManager`、玩家移动管理类 `PlayerMovementManager` 等等。

但对于场景，这样说起来就有点空洞，那我举个非常常见的负面例子。Godot 开发的教程里面，经常会出现一个情况：就是场景中的人物角色，头顶上需要加一个 UI，显示血条。这个时候，很多教程就是直接把相关的 ProgressBar UI 节点往玩家场景里面一挂，就完事了。

但其实这个就不太符合单一职责原则——因为血条的显示，其实和玩家这个行为体本身关系并不是这么紧密——一般情况下，敌人也需要显示血条，那这个时候你就得往敌人场景上也挂一个 ProgressBar UI 节点，同时在敌人代码里写一堆更新血条 UI 的逻辑！

更好的做法，就是把这个血条 UI 提取成一个子场景，这样方便我们在不同人物单位上复用，相关代码也就更加内聚了。这也就符合了单一职责原则。

#### 3.1.3.3 开闭原则（OCP）

该原则本身是 Bertrand Meyer 在 1988 年提出的，指：**设计良好的软件应该易于扩展，同时抗拒修改**。网上很普遍的一种简便说法，也叫做“**对扩展开放，对修改关闭**”，这也是开闭原则名字的由来。

有人想找茬，如果还记得**《2.2》**里我的措辞，可能就可以开心一下了：“嗨嗨嗨，你那里还说好的代码架构要易于修改，这些翻车了吧！人家大佬们都说要‘抗拒修改’，要‘对修改关闭’！”——所以我之前说，重要的是架构思想本身，而不是咬文嚼字的装逼。很可惜，我得表示：他们并不能高兴太久，让我们看看这句话真正的含义。

这句话的实际意思是：**设计良好的计算机系统应该在不需要修改的前提下就轻易被扩展。**这个含义你看在**《2.2》**中，是不是和我说的“**容易新增**”类似？需求都改了的时候，代码该修改的时候自然得改。**开闭原则是针对新增功能时，**这很关键。

理解这一点，那你回想起我们**《2.3.3》**总结的**让依赖方向形成有向无环图**，以及**《2.3.4》**中说的**让依赖方向指向代码稳定的方向**。其实他们都是在让你容易做到开闭原则——因为底层是稳定的依赖，那你要在上层开发新功能时，就能最大层度的利用旧代码的可复用性，然后全新的功能自然就是在对应层级单独写新的。

以上是在代码层级做到开闭原则，对于场景则主要可以体现在新功能最好利用子场景的组合来设计。但说实话，因为场景本身作为显示层的一部分，是比较不稳定的，经常需要添加或修改节点；所以想完全保证开闭原则——在新增功能时不修改，而是扩展——其实还是挺难的。那其实对于它（场景），我们就是尽量保证我们新增功能时修改程度最小即可。

#### 3.1.3.4 里氏替换原则（LSP）

里氏替换原则对应的是 1988 年 Barbara Liskov 提出的关于定义子类型的一段话：“**这需要一种可替换性：如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型**”

头看疼了？那我们简单说一下重点，对于 Godot 游戏开发的情境下，其实就是说 GDScript 类、场景中的“继承”（以及 C# 中的接口实现），需要做到：**继承父类的子类、继承父场景的子场景、（C# 中实现接口的类），他们要可以在任何情况下直接替换父类、父场景、（接口）。**换言之，也就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

经常提到的一个例子，就是正方形不能作为长方形的子类实现——因为正方形要求长宽相等，所以对于长方形的长宽修改操作（可以分别修改），并不能替换成正方形的长宽修改（必须一同修改）。

所以其实判断你是不是违反了 LSP 的一个方法，就是看：你在使用一个父类的时候，是不是多了很多子类的判断逻辑，然后增加了不同的处理逻辑。如果是这样，那往往就是违反了 LSP。

所以这一原则其实就是指导你什么时候选择继承父类，选择哪个作为父类。（对于 Godot 就是节点继承类型、继承场景的选择）

但有个非常经典的编程思想就是“**组合优于继承**”，我们都是优先考虑用组合的方式，而不是继承的方式，来实现功能扩展。比如我们 Godot 中的节点树，其实就也是对应“组合”这个思想。所以其实里氏替换原则因为主要是针对类似继承的情况，所以应用机会也是也越来越少了。

但一旦是确实需要继承的情况，那我们还是可以通过 LSP 来指导我们选择合适的父类、父场景、（以及 C# 的接口）。

#### 3.1.3.5 依赖反转原则（DIP）

依赖反转原则具体是说：**如果想要设计一个灵活的系统，在源代码层次的依赖关系中，就应该多引用抽象类型，而非具体实现**。

一定程度上，这和我们**《2.3.4》**中提到的：依赖方向需要指向稳定的方向，是有相关性的。因为代码调用哪些方法是相对稳定的，而那些方法的具体实现是相对容易修改、不稳定的。因此得出的结论就是依赖反转原则。

这里的“依赖反转”体现在——分属于两个层级的 A 类和 B 类，如果 A 类直接调用 B 类，依赖方向和控制流方向是一致的，A 依赖 B；按这个原则做，让 A 是调用同层级中的抽象类型 IB，它们在一个分层内，而 B 在另一个分层中实现抽象类型 IB。此时两个分层之间依赖方向和控制流的方向是相反的——B 依赖抽象类型 IB（实现是一种依赖**《2.3.1》**），而 A 通过 IB 调用 B，两者方向相反。

对于 GDScript 来说，因为 没有接口这种概念，一般情况下能做的，就仅仅是是**没用到自定义脚本的属性、方法时，我们就是优先使用代码继承的 Godot 提供的原生节点父类型来表示其类型**。从而保证我们代码的稳定性。

但对于自定义脚本的属性、方法本身，是很难提取一个稳定的抽象概念。要么故意提取一个父类，提供方法的空实现，然后子类来真正写实现（但前面说过，组合优于继承，继承的灵活性还是很低的，而且需要满足**《3.1.3.4》**里氏替换原则）；或者是采用 `Callable` 数组，或者是用 `has_method()` 配合动态类型来做类似接口的相关功能。但这还是有点复杂的，所以按道理，这条原则能使用到 GDScript 的方面也不多。

但在 C# 中，因为有接口、委托这些语法特性，所以应用 DIP 相对简单。就是各代码层级之间都用抽象的接口进行依赖反转。后续更高阶的架构设计，我们会常常用到这一点。

（顺便一提，对于网络上经常看到的问题：为什么一个实现类的时候，也需要定义一个接口？其实背后很重要的原因，也是对应依赖反转原则的应用，让架构中代码修改更灵活）

以上，我们算是把 SOLID 原则简单介绍了一下，详细的内容，可以按照关键字去搜索更权威的解读。然后按照我们这里大概思路，应用到 Godot 游戏开发过程中。

## 3.2 C# 微观代码组织

以上就是我想聊的 GDScript 相关的微观代码设计内容了，想必 C# 读者也能获取到一些有益的思考。接下来，我们则专注于 C# 使用者，如果你是笃定心思只用 GDScript 的读者，那就可以跳过了。（但是我还是挺希望你看看**《3.2.1》**的）

### 3.2.1 GDScript 还是 C#，这是问题吗？

在讨论 C# 的微观代码设计前，我们先聊一个网上同样争论不休的话题：Godot 游戏开发是用 GDScript 和 C#？

这个破问题（是的，我觉得这个问题很烂！）也能吵吵半天，给我这个两者都用过的人的感觉就是：你们确定你们不是因为只用 GDScript，或者只用 C#，然后就来这里党同伐异的？还有的就是根本全没用过，说不定 Godot 都没下过的引战乐子人！

在我看来，问题很简单：**这并不是一个互斥的选项，你其实可以选择 Godot + GDScript & C#** ！真正需要讨论的，从来不是“GDScript 还是 C#”这样一个烂问题，而是在 Godot 下，如何踏踏实实、最大限度地用好 GDScript 和 C#。

（甚至以及其他语言！所以准确来说是 **Godot + GDScript & .NET & C++**！而且这还只是说了官方的支持，算上社区支持的选择，就更多了）

是的，自己去看 Godot 官方文档 [**手册-编写脚本-核心特性-跨语言脚本**](https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/cross_language_scripting.html)，Godot 就是支持你同时使用 GDScript 和 C# 的。而我自己当前项目里就是这样做的，虽然主要用 C#，但因为 Godot 很多插件是用 GDScript 写的，你要使用或者修改的话，还是得会 GDScript，并且在两者之间互操作！

所以我建议是：**可以从 GDScript 入门**（我自己就是这样），因为前面提到的 Godot 内很多插件还是用 GDScript 写的，想要改，就不得不会。而且 GDScript 和 Godot 编辑器还是配合得不错的，还有内嵌脚本、拖拽节点变成代码之类的小功能。

而且 GDScript 语言本身相对轻巧简单，语法不复杂，所以对于新手来说相当友好。不需要太多编程知识的学习，就能入门游戏开发了。这些自然是它不可否认的优势。

但是**熟悉 GDScript 后，（尤其是有相对丰富的编程经验的程序员朋友们）可以尽快过渡到 C#**。

不过，首先提一下：这个过渡对于完全新手小白的话，可能是有一定难度的。一方面是多了很多语法特性，新手很容易被繁多知识所淹没（但当然，你可以只先使用和 GDScript 相同的那一部分功能，这样会轻松些）。另一方面就是，C# 相比于 GDScript 来说，确实会多一些特有的坑（后面会提到）。所以新手可以先把 GDScript 真正熟悉以后，再考虑 C#，有了编程经验，换语言其实就相对来说不难了。

但是对于本身已有经验的程序员来说，那其实就并不难：一方面是前面说到的 C# + GDScript 两者之间能方便的互操作，另一个主要的方面，其实就是 Godot API 对于 GDScript 和 C# 来说，没有本质上的区别。表面上的差异，则都在官方文档 [**手册 - 编写脚本 -  C#/.NET**](https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/c_sharp/index.html#godot-api-for-c) 下的子章节涵盖了：

1. C# API 与 GDScript 的差异（命名格式不同，以及一些具体分类差异）
2. C# 集合（GDScript 集合和 C# 间的对应关系）
3. C# Variant（GDScript Variant 类和 C# 类型间的对应关系）
4. C# 信号（怎么在 C# 里定义与连接信号）
5. C# 导出属性（@export 相关的怎么在 C# 中使用）
6. C# 全局类（有的人不知道为啥写的 C# 节点脚本或者资源（Resource）类在 Godot 编辑器里的“添加节点”和“创建资源”对话框找不到！有类似问题，就快去看这篇）

根据上面的内容，基本就能从 GDScript 过渡到 C#。

但我这里说“基本”能过渡，就是因为有个文档里没说的坑：**就是 Godot C# 因为多了编译的步骤，所以对于之前 GDScript 中 @tool 的这种编辑器工具类（在 C# 里是 [Tool]）很容易出问题**。这个我这里重点说一下。

对于它，请重点参考 Godot 官方关于 **C# 编译时卸载程序集失败报错**（这个会是你用 C# 写编辑器工具时，最容易看到的一个错误爆红信息……）的 issue 78513 的内容（https://github.com/godotengine/godot/issues/78513）。

以及而对于整个 [Tool] 编辑器工具类在编译时，因为不透明的序列化、反序列化机制导致的各种问题，请主要参考社区提交的提案 9001《**让 C# tool 脚本重新加载过程更容易使用**》（https://github.com/godotengine/godot-proposals/issues/9001）总结了各种容易出问题的场景，可以对照着解决不少问题。

此外还有一个**编辑器工具会两次调用构造函数、_EnterTree()、_Ready()** 的 issue 40970（https://github.com/godotengine/godot/issues/40970），非常搞笑的是，从 Godot 3.2 至今仍没修复，所以你进行相关 [Tool] 编辑器工具开发时也需要考虑到。

否则就得自己去啃源码了…… 非常遗憾的是，Godot 官方文档目前仍然没有包含相关内容，所以确实非常容易踩坑。这里我把相关问题基本都罗列了一下，基本把这些看完，C# 的编辑器工具 [Tool] 类还是能用的。（在此吐槽一下：Godot 官方文档是真的一点也不愿意指路一下用户吗？！只好由我淌坑和总结经验后在此简单总结下了）

但之所以顶着上面一些缺少官方文档的坑，我自己也主要使用 C# 作为项目主体代码，其实根本原因就是——Godot，尤其是 GDScript，还是太年轻了——它本身主要目的还是为了解决游戏开发的问题，而并不是在编程语言上的创新和规范使用。

所以，相比于 C# 历史更久、语法特性更丰富、底层机制更完善、生态更成熟的优势，GDScript 肯定是一时没法直接相提并论的。比如随便举个例子：像 4.4 GDScript 才给 Dictionary 加了“泛型”，之前只有 Array 有；而它这个所谓“泛型”，截至 4.4 都依然没法嵌套。而泛型在 C# 中早已经非常成熟。类似的，还有 lambda 相关功能也是 GDScript 还在完善中。

就更不提 C# 其他特有于 GDScript 的各种方面了（接口、访问修饰符、命名空间、解决方案下的多项目等等），接下来我们其实也会聊到不少。这些在我们进行较大项目的架构设计时，是非常有用的。

所以我个人还是挺建议学有余力的程序员们，用 Godot 做游戏开发的话，把相关的 GDScript、C# 语言都去学习一下的，这样就能在合适的场景使用合适的语言了。个人看法是：**只要不是小型项目，C# 为主、GDScript 为辅的话，后期维护会轻松不少**。

必须指出的 GDScript 现在生态上很明显的问题，就是它的编辑器缺少重构相关工具。C# 的 IDE（集成开发环境，你可以简单理解为集合了各种开发工具的更强大的代码编辑器，常见的就是微软公司的 Visual Studio 和 JetBrains 公司的 Rider）能够提供不少**重构工具**支持。它们可以帮助我们**快速修改变量、函数、类的名字，提取变量、函数、类，移动代码而自动修改相关依赖**等等。

有人可能会说，Godot 里的 GDScript 编辑器不是也能用 Ctrl + Shift + R 进行全局替换吗？提取相关内容，那不就复制粘贴，稍微改一下就行？那你就得想到：一方面 C# IDE 提供的重构工具是全自动的，你要做的仅仅是按下快捷键或者右键选择相应菜单；另一方面，对于那些依赖非常复杂的类，一旦有重名的情况（包括中间字符串相同的情况），GDScript 编辑器里，你就得自己一个一个决定是不是真正你要替换的内容了！当这个名字是个通用的名字，而被各种地方使用时，重构它会是多么令人感到畏惧的场景！

回想我们前面说的好代码架构核心思想之五：要注重可重构性（**《2.3.5》**），那 GDScript 对于稍微大些规模的项目来说，重构就是非常痛苦的。重构过程痛苦，你就越不愿意重构；越不重构，就想房间不打扫一样，必然在后续维护过程中快速导致架构腐化，退化成屎山代码……这点在前面**《2.3.5》**已经详细论述过，不再重复。

综上，我给出了对**成熟程序员 C# 为主，GDScript 为辅**的建议。对于**新手小白，那可以先把 GDScript 玩熟悉再说，等感觉到瓶颈时，再学习 C#**，毕竟不能强求一步登天。

在 C#、GDScript 之外，说些题外话：

- Godot 准确来说，并不是仅仅支持了 C#，而是支持了 .NET。虽然，挂节点脚本时只能挂 C# 脚本，但可以通过 C# 脚本与其他 .NET 语言的互操作，从而用上其他 .NET 语言。比如我自己之前其实也用过 **F#** 语言做 Godot 开发。对 F# 感兴趣的话，可以留言，我有空也能总结一下相关开发心得。另外 .NET 下的 **VisualBasic** 语言的话，则我还暂时没试过，不确定是否可行。
- 其实更深入一些底层，Godot 游戏开发过程中，还能用 **C++**（话说毕竟引擎本身就是 C++ 写的）。但因为我自己没有实际使用过，这里就多聊了，感兴趣的请参考官方文档中 [**手册 - 编写脚本 - GDExtension**] C++ 相关部分。

以上，就是对于 Godot 官方支持下能用语言的概述了，希望能有帮助。

### 3.2.2 建议能不用 Godot 功能时，就优先用 C# 类似的

聊完 Godot 官方支持的可用语言，那我们就能来正式聊聊针对 C# 的建议了。

前面**《3.1.2》**就已经简单提到 C# 的 Object 类与 GDScript 的 Object 类（C# 里就是 GodotObject 类）的区别，**我建议 C# 使用者们优先使用 C# 自己的同等功能的类**。对于前面话题，是因为 C# GC 机制更完善，能够直接避免引用计数法的垃圾回收的坑。

那这里我要把这个结论推而广之，建议你在其他方面，同功能下也是优先使用 C# 下的语法、类。接下来具体举例子。

首先是 **Godot 信号，我建议使用事件（event）替代**。

除了必须继承 Node 类的节点脚本，全面放弃要求我们强耦合于 Godot 节点的功能，而使用 C# 生态下的功能

1. Godot 原本使用自定义信号实现的功能，都转而使用 C# event 事件（注意：需要自己维护事件绑定和解绑的生命周期了）

**集合**

### 3.2.3 接口、委托、lambda

### 3.2.4 var 类型推断

### 3.2.5 Nullable 检查

1. Godot 默认项目不启用 **Nullable 检查**，而 Rider 新建项目会启动 Nullable。建议打开（默认 Godot 项目也能自己改为打开），让我们空引用更安全。

### 3.2.6 优先使用属性，而非字段

1. 建议优先使用属性（也是《More Effective C#》的建议），重构的时候更为方便。因为接口可以声明属性，而不能声明字段。
2. 尤其是 Godot `[Export]` 变量，建议用属性。因为你重构的时候如果修改字段访问修饰符，会导致命名风格变化（`public` 大写开头驼峰式，`private` 下划线小写开头驼峰式），而 Godot `.tscn` 文件不会同步修改，导致之前配置的内容丢失。

# 4 等级二：简单架构知识——容易理解上手的宏观架构组织

## 4.1 全局变量、静态单例

Godot 节点间相互调用时寻找依赖的麻烦

1. 通过 `GetNode<节点类型>("节点路径")` 获取
2. 通过 `GetNode<节点类型>("%场景唯一名字")` 获取
3. 通过 `[Export] 节点类型 字段名` 注入
4. 通过 `GetTree().GetFirstNodeInGroup("分组名")` 获取
5. 通过 Godot 的全局自动加载节点（单例）里面的字段自行存储和获取

## 4.2 信号总线

## 4.3 显示、逻辑、数据三层架构详解



## 4.4 GoF 设计模式：究竟在何时使用？

反例：if-else 强行拆分成策略模式、简单 new 逻辑强行使用工厂模式

真正适合场景：跨层级时，为了保证避免同层级间调用，交给高层级编排。



lambda、委托、函数式编程简化设计模式



# 5 等级三：进阶架构知识——复杂但灵活的宏观架构组织

## 5.1 依赖注入

反驳很多人说的依赖注入没必要：

**《1.1》**中提到的 Godot 的[**手册 - 最佳实践 - 场景组织**]官方文档，里面也说了：“如果场景必须与外部环境交互，经验丰富的开发人员会建议使用**依赖注入**。该技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部环境的类可能会无意中触发 Bug 和意外行为。”

如何自行实现？“组合根”

C# 现成容器：

- Microsoft.Extensions.DependencyInjection
- Autofac
- 等等

## 5.2 C# 项目：控制层级间的依赖方向

1. 让编译器自动校验、报错，强行要求我们按架构实现落地代码；而不会因为随意调用而一不小心就写出了高度耦合的代码

## 5.3 节点层的依赖倒置：真正的逻辑完全解耦

### 5.3.1 问题

**《3.1.2》Godot C# 节点过重**的麻烦

1. Godot 源生成器会根据我们继承了 Node 类的分部（partial）类生成代码
2. 我们不需要让 Godot 管理生命周期时，不需要继承 Node；不需要让 Godot 管理内存垃圾清理时，不需要继承 GodotObject；而 Godot 信号等功能要求我们传递参数必须是 GodotObject 或者基本类型
3. 之前碰到的，即使 SetProcess(false)、Visible = false 的节点，依然会占用每帧的处理时间！

我们可以把底层代码作为不依赖 Godot 的 C# 代码，对它的层级进行设计。但本身节点的脚本，必须继承 Node 类。

1. 它们的数据、逻辑，我们应该如何解耦出来？

多个节点间有复用逻辑时的麻烦

1. 拆分一个新的节点基于组合放到这多个节点下？但如前文提到，Godot 节点很重！

由于生命周期的存在，我们往往需要把很多子节点的初始化逻辑放在场景根节点处理。

1. 一方面是会使得父节点的逻辑里面耦合了很多子节点的逻辑。
2. 另一方面，如果我们节点间的父子关系变化（比如变成平级节点，或者直接父子关系颠倒），此时就要因此同步修改、重构和编写相关代码，非常麻烦。

### 5.3.2 解决

Godot 节点脚本本身保持质朴，仅仅作为它数据的存储和继承 Godot 默认方法的调用器。

把以下相关自定义的业务逻辑的发起过程，从节点类文件中全部解耦到外面写，包括但不限于：

1. 编辑器 [Export] 变量的 getter 和 setter 逻辑
2. 生命周期
   1. C# 构造函数：对应 GDScript 的 _init()
   2. 进入场景树时执行的方法：_EnterTree()
   3. 节点就绪时执行的方法：_Ready()
   4. 退出场景树时执行的方法：_ExitTree()
3. 游戏循环：_Process(double delta) 等（还有 Physics 变体）
4. 用户输入：_Input(InputEvent e) 等（还有 Unhandled、Shortcut 等变体）

节点层作为最外层的表现层，唯一逻辑是负责上下文层的初始化和切换；上下文层则管理内部应用层、领域层、基础设施层从高到低三层的依赖注入。节点层本身通过抽象层的接口，注册到基础设施层供内部高层级查询和调用。

1. 节点层作为数据和 Godot 方法的容器，利用节点抽象层接口作为适配器，倒置到基础设施层内。
   1. 问题 2 中的业务逻辑，通过事件触发
   2. 这点很重要，缺了这一步，我自己项目原先的架构设计，其实也并没真正做到数据、逻辑、展示分离——因为节点层内的这三者仍然耦合。只有通过这样倒置到基础设施层，才真正在几乎全项目的层面做到三者解耦。
2. 这样上下文层以内的整个控制流非常清晰：
   1. 顶层：应用层编排业务逻辑（调用基础设施层查询出所需数据、调用领域层执行各种具体核心逻辑）
   2. 中层：领域层本身无状态，负责可复用的核心逻辑（根据传入数据，调用特定基础设施层来真正变化数据状态）
   3. 底层：基础设施层（维护数据相关的查询和修改逻辑，使得所有可变状态集中于此）
   4. 向下可以直接方法调用，向上统一使用事件通知，相同层级不允许互相调用

# 6 等级四：未来架构扩展

1. MVVM
2. 事件驱动：
   1. 响应式编程
3. 函数式编程思想
   1. 副作用
   2. 纯函数
4. 多线程
5. Mod
6. 性能优化
   1. 计算着色器
   2. ECS？
7. 网络
